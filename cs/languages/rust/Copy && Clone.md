
[Copy и Clone](https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src/libcore/marker.rs#L272) - это важные трейты, которые помогают управлять копированием и клонированием объектов. 

---
## Copy

`Copy` - это трейт для типов, объекты которых можно копировать простым побитовым копированием (`memcopy`), то есть просто скопировать биты, представляющие этот объект без каких-либо дополнительных действий.

например при простом присваивании $y = x$ данные фактически копируются и получаются две независимые копии данных. То есть исходный экземпляр остаётся валидным.

Требования в типам, реализующим `Copy`: Тип, реализующий данный трейт должен быть `trivially copyable`, то есть он не должен быть связан с ресурсом, необходимым в освобождении. В терминах языка `Rust` это означает, что к типа не должно быть реализации трейта `Drop`, а также в случае, если тип составной, то все его поля также должны реализовывать `Copy`.


Таким образом, трейт `Copy` обычно реализуют примитивные типы, такие как `i32`, `f64`, `bool`, `char`, а также кортежи и структуры и прочие составные типы, содержащие только объекты `copyable` типов.

И важно понимать, что данный трейт является *маркером*, то есть он не требует реализации каких-либо методов от типа вручную. Компилятор языка `Rust` автоматически добавляет реализацию этого трейта для всех типов, которые встречает, если эти типы поддерживают описанные выше требования.

---
## Clone

`Clone` - это трейт для не примитивных типов, объекты которых могут включать дополнительные действия, такие как выделение новой памяти.

То есть тип, реализующий трейт `Clone`, может создать *глубокую копию* самого себя. Это представляет из себя более сложную операцию, чем просто побитовое копирование.

Для клонирования объекта необходимо явно вручную реализовать метод `clone(&self) -> Self` для соответствующего типа. Этот метод как раз и описывает, каким образом должна быть создана новая копия.

Пример для объекта нетривиального типа:

```Rust
let v: Vec<u8> = vec![1, 2, 3];
let w = v.clone();
``` 

=> `Clone` поддерживают любые типы, однако для некоторых нетривиальных типов реализация `Clone` представлена по умолчанию стандартной библиотекой:
- `String`
- `Vec<T>`
- `Option<T>`
- `Result<T>`
- Кортежи, массивы и перечисления,структуры элементы и поля которых не поддерживают `Copy`.
- `Box<T>`, если `T` не реализует `Copy`.
- `Rc<T>`, если `T` не реализует `Copy`
- `Arc<T>`, если `T` не реализует `Copy`.
- ...

---
## #[derive(Copy, Clone)]

`#[derive(Copy, Clone)]` - это атрибут, который инструктирует компилятор автоматически сгенерировать реализации данных трейтов для данного типа.

```Rust
#[derive(Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = Point { x: 10, y: 20 };
    let p2 = p1; // memcpy
    let p3 = p1.clone(); // explicit clone

    println!("p1: x = {}, y = {}", p1.x, p1.y);
    println!("p2: x = {}, y = {}", p2.x, p2.y);
    println!("p3: x = {}, y = {}", p3.x, p3.y);
}
```

=> Использование `#[derive(Copy, Clone)]` упрощает реализацию трейтов `Copy` и `Clone` для собственных типов, если все их поля уже реализуют эти трейты. 

Это позволяет использовать собственные типы в контекстах, где требуется копирование или клонирование, без дополнительных усилий.

---

## Special links with advanced information about these traits

1. [Implementation of Copy and Clone traits](https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src/libcore/clone.rs)
2. [Advanced](https://doc.rust-lang.org/std/clone/trait.Clone.html)