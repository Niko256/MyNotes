`Smart pointers` - это важнейший инструмент во многих языках программирования для безопасного управления динамическим ресурсом.

Умные указатели представляют из себя структуры данных, работа которых схожа с работой "сырых" указателей, но в то же время они обладают дополнительными метаданными и свойствами, по сравнению с обычными указателями и ссылками. 

`Rust` с его концепцией владения и заимствования имеет дополнительное различие между ссылками и умными указателями.
- в то время, как ссылки только заимствуют ресурс, умные указатели _владеют_ ресурсом, на который указывают.

---

## `Box<T>`

Наиболее простой умный указатель - `Box<T>`.

***Свойства:***
- используется для выделения ресурса на куче (heap).
	- на стеке хранится адрес выделенного ресурса

- зачастую необходим при работе с [[Dynamically sized types]]
	- в частности при работе с trait-объектами. Очень удобным способом является их хранение в виде `Box<dyn Trait_name>`

- **Единоличное владение**
	- `Rust` гарантирует, что только `Box<T>` владеет ресурсом в любой момент времени
	- с помощью семантики перемещения `Box<T>` передает владение над ресурсом, а предыдущий владелец теряет к нему доступ
	- Когда `Box<T>` выходит из области видимости, компилятор вызывает `drop` и выделенный ресурс освобождается.

- **Иммутабельность по умолчанию**
	- попытка изменить данные по адресу выделенного ресурса приведёт к противоречию концепции единственного владения.


В каких же случаях стоит использовать `Box<T>`?

1. ***Хранение данных в сегменте `heap`***

``` Rust
let b = Box::new(5); // allocate memory on heap for i32 
```


2. ***Хранение рекурсивных типов***
	-  Рекурсивный тип - это тип, компонентой которого является сам этот тип
	- так как размер рекурсивного типа неизвестен на этапе компиляции, необходимо хранить его в виде `Box<Rec_type>`

``` Rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

fn main() { let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil)))))); }
```


3. ***Хранение и взаимодействие с DST***
	- размер динамических типов данных неизвестен на этапе компиляции, а значит, что необходимо их "обернуть" в умный указатель, размер которого определён.

``` Rust
trait Draw {
    fn draw(&self);
}

struct Button;
struct Background;

impl Draw for Button {
    fn draw(&self) {
        println!("Drawing a button");
    }
}

impl Draw for Background {
	fn draw(&self) {
		println!("Drawing a background");
	}

}

let button: Box<dyn Draw> = Box::new(Button);
button.draw();
```


---

## `RC<T>` ([Reference counting](https://doc.rust-lang.org/alloc/rc/struct.Rc.html))

### Motivation 

В предыдущем параграфе был рассмотрен тип `Box<T>`. Однако он основывается на принципе единоличного владения. Он гласит, что каждый объект имеет единственного владельца, и когда владелец выходит из области видимости, ресурс освобождается через `drop`. Этот принцип является краеугольным камнем гарантий безопасности ресурса, предотвращая на этапе компиляции такие проблемы, как двойное освобождение ресурса или использование после освобождения.

Однако строгая модель единоличного владения не всегда удобна. Часто возникают ситуации, где некоторый ресурс по своей природе должен иметь нескольких владельцев (например ориентированный граф, где несколько узлов могут ссылаться на один определённый дочерний узел). Кто же тогда должен владеть этим узлом? Если назначить единого владельца, то другие узлы смогут иметь лишь временные заимствования, что может привести например к проблемам с временами жизни. То есть в идеале, дочерний узел должен существовать до тех пор, пока на него ссылается хотя бы один родительский узел 

Для решения таких задач Rust предоставляет механизм **разделяемого владения (shared ownership)** через **умные указатели со счетчиками ссылок**: `Rc<T>` и `Arc<T>`.

Основная мотивация для использования `Rc<T>` и `Arc<T>` — это позволить нескольким частям программы "совладеть" одним и тем же выделенным ресурсом. Ключевая идея заключается в том, что ресурс остается живым до тех пор, пока существует хотя бы одна "владеющая" ссылка на него. Как только последняя такая ссылка исчезает, ресурс безопасно освобождается.

Это достигается путем подсчета количества активных ссылок на ресурс. Каждый раз, когда создается новая владеющая ссылка, счетчик увеличивается. Каждый раз, когда ссылка выходит из области видимости, счетчик уменьшается. Когда счетчик достигает нуля, ресурс освобождается.

## `Properties`

`Rc<T>` - это умный указатель, который предоставляет множественное владение объектом в однопоточной среде, благодаря счётчику ссылок.


- Счётчик ссылок внутри `Rc<T>` позволяет контролировать число владельцев данного объекта. 
	- При появлении нового владельца -> счётчик ссылок инкрементируется.
	- При отсутствии владельцев ресурс освобождается, а счётчик обнуляется.

- используется только в однопоточном сценарии

- `Rc<T>` реализует трейт `Deref`, позволяя получить иммутабельную ссылку (`&T`) на вложенные данные. Это означает, что `Rc<T>` по умолчанию предоставляет только **разделяемый неизменяемый доступ**. Невозможно получить `&mut T` напрямую из `Rc<T>`, так как это нарушило бы правила заимствования (несколько владельцев не могут одновременно иметь изменяемый доступ).

- является аналогом `std::shared_ptr<T>` в `C++`

- `Rc<T>` **не является потокобезопасным** (`!Send` и `!Sync`, даже если `T` потокобезопасно, сам механизм подсчета `Rc` — нет). Инкрементация и декрементация счетчика ссылок не являются атомарными. Попытка использовать `Rc<T>` для разделения данных между потоками приведет к ошибке компиляции или, что хуже, к гонкам данных на счетчике ссылок во время выполнения (если бы компилятор это позволил).

То есть `Rc<T>` идеален для ситуаций, когда:

- Ресурс должен иметь несколько владельцев в пределах одного потока.
    
- Необходимо избежать дорогостоящего копирования больших структур данных.
    
- Реализация структур данных, где узлы могут совместно использоваться (например, деревья выражения, некоторые виды графов).

Поскольку `Rc<T>` предоставляет только неизменяемый доступ, как быть, если нам нужно модифицировать разделяемый ресурс? Здесь на помощь приходит паттерн внутренней изменяемости! Можно обернуть данные внутри `Rc` в `Cell` или `RefCell`:

- `Rc<Cell<T>>`: Для разделяемого владения `Copy`-типами с возможностью их замены (`set`) или получения копии (`get`).
    
- `Rc<RefCell<T>>`: Классический паттерн для разделяемого владения изменяемым ресурсом в однопоточном коде. `Rc` управляет временем жизни данных, а `RefCell` предоставляет `API` для безопасной мутации через `borrow_mut()`.

![Arc|400](https://i.imgur.com/hTaMynk.png)


``` Rust
use std::rc::Rc;

enum List {
    Cons(i32, Rc<List>),
    Nil,
}

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));
    
    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));
    
    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    
    println!("count after c goes out of scope = {}",Rc::strong_count(&a));
}

// OUTPUT

count after creating a = 1  
count after creating b = 2  
count after creating c = 3  
count after c goes out of scope = 2
```


## `Arc<T>` ([Atomic reference counting](https://doc.rust-lang.org/std/sync/struct.Arc.html))

`Arc<T>` — это аналог `Rc<T>`, предназначенный для сценариев, где данные должны разделяться **между несколькими потоками**. Название расшифровывается как `Atomically Reference Counting`.

Ключевое отличие заключается в том, что `Arc<T>` использует **атомарные операции** для изменения счетчика ссылок. Атомарные операции гарантируют, что инкремент и декремент счетчика происходят как единая, неделимая операция с точки зрения других потоков. Это предотвращает гонки данных при одновременном доступе к счетчику из разных потоков.


Благодаря атомарным операциям, `Arc<T>` является потокобезопасным. Он реализует трейты `Send` и `Sync`, если вложенный тип `T` также реализует их. Это означает, что `Arc<T>` можно безопасно передавать между потоками (`Send`) и разделять доступ к нему через ссылки между потоками (`Sync`).

Итак, `Arc<T>` необходим в следующих сценариях:

- Требуется разделять владение данными между несколькими потоками.
    
- Необходимость передать владеющую ссылку на ресурс в другой поток (например, при запуске потока с `std::thread::spawn`).
    
- Реализация потокобезопасных структур данных.

``` Rust
use std::sync::Arc;
use std::collections::HashMap;
use std::thread;
use std::time::Duration;

struct Cache {
    data: HashMap<String, String>,
}

impl Cache {
    fn new() -> Self {
        Cache { data: HashMap::new() }
    }

    fn get(&self, key: &str) -> Option<&String> {
        self.data.get(key)
    }

    fn set(&mut self, key: String, value: String) {
        self.data.insert(key, value);
    }
}

fn main() {
    let cache = Arc::new(std::sync::Mutex::new(Cache::new()));

    // Writer thread
    let cache_writer = Arc::clone(&cache);
    thread::spawn(move || {
        for i in 0..5 {
            let mut cache = cache_writer.lock().unwrap();
            cache.set(format!("key{}", i), format!("value{}", i));
            thread::sleep(Duration::from_millis(100));
        }
    });

    // Reader thread
    let cache_reader = Arc::clone(&cache);
    thread::spawn(move || {
        for i in 0..5 {
            let cache = cache_reader.lock().unwrap();
            if let Some(value) = cache.get(&format!("key{}", i)) {
                println!("Got value: {}", value);
            }
            thread::sleep(Duration::from_millis(150));
        }
    }).join().unwrap();
}
```

---

## ## [Reference cycles](https://www.youtube.com/watch?v=rzYS7dwGrhA)

Циклические ссылки - это ситуация, в которой 2 или более объектов ссылаются друг на друга.

Данная проблема может привести к утечкам памяти, ведь ресурс объектов никогда не будет освобожден после выхода из их локального `lifetime`.


``` Rust
use std::rc::Rc;
use std::cell::RefCell;

struct Node {
	value: i32,
	next: RefCell<Option<Rc<Node>>>,
}

fn main() {
	let a = Rc::new(Node{
		value: 1,
		next: RefCell::new(None),
	});

	let b = Rc::new(Node{
		value: 2,
		next: RefCell::new(Some(a.clone())),
	})

	if let Some(ref mut next) = *a.next.borrow_mut() {
		*next = b.clone();
	}
}
```


В этом примере `a` и `b` ссылаются друг на друга через `Rc`, `RefCell`.

Данный случай порождает циклическую ссылку и объекты `a` и `b` не будут удалены даже при выходе из функции `main`. 


### [std::rc::Weak](https://doc.rust-lang.org/std/rc/struct.Weak.html)

Для решения проблемы циклических ссылок в Rust можно использовать `Weak` из модуля `std::rc`.


`std::rc::Weak` позволяет временно ссылаться на объект, при этом не инкрементируя счётчик ссылок.


``` Rust
pub struct Weak<T, A = Global>
where A: Allocator, T: ?Sized,{
/* private fields */
}
```


- `std::rc::Weak` представляет из себя "слабую" версию умного указателя `Rc<T>`. 

- данная структура данных хранит **невладеющую ссылку** на объект.

- возможно преобразовать `Weak<T>` до `Rc<T>` c помощью метода `upgrade()`.
	- это позволяет получить доступ к объекту, на который ссылался `Weak<T>`. 

	- данный метод возвращает `Option<Rc<T>>`>`
		- если объект, на который указывает `Weak<T>` ещё существует, то метод вернёт `Some(Rc<T>)`, иначе - вернёт `None`.
		
		- в случае, если `upgrade` вернёт `Some(Rc<T>)` "сильный" счётчик ссылок увеличится на единицу


``` Rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

struct Node {
    value: i32,
    next: Option<Rc<RefCell<Node>>>,
    prev: Option<Weak<RefCell<Node>>>,
}

impl Node {
    fn new(value: i32) -> Rc<RefCell<Node>> {
        Rc::new(RefCell::new(Node {
            value,
            next: None,
            prev: None,
        }))
    }
}

fn main() {
    // creating two nodes
    let node1 = Node::new(1);
    let node2 = Node::new(2);

    // linking nodes to doubly linked list
    node1.borrow_mut().next = Some(node2.clone());
    node2.borrow_mut().prev = Some(Rc::downgrade(&node1));

    // Now node1 && node2 are linked
    // node1 -> node2
    // node2 -> node1 (through the Weak)

    // cheching, that node2 can get access to the node1 through the Weak ref
    if let Some(prev_node) = node2.borrow().prev.as_ref().and_then(|weak| weak.upgrade()) {
        println!("Node2's previous node value: {}", prev_node.borrow().value);
    } 
    
    else {
        println!("Node2's previous node is gone.");
    }

    // deleting "strong ref" to node1
    drop(node1);

    // Now node1 is deleted, and Weak ref into node2 can't get upgraded anymore
    if let Some(prev_node) = node2.borrow().prev.as_ref().and_then(|weak| weak.upgrade()) {
        println!("Node2's previous node value: {}", prev_node.borrow().value);
    } 
    else {
        println!("Node2's previous node is gone.");
    };
}
```


**разумные случаи использования `std::rc::Weak`:**

- Иерархические структуры данных
	- При работе с иерархическими структурами данных, такими как деревья или графы, `Weak<T>` может использоваться для создания ссылок от дочерних узлов к родительским узлам.
		- Это позволяет избежать циклических зависимостей, которые могут возникнуть, если дочерние узлы будут хранить сильные ссылки на родительские узлы.

- Временное хранение ссылок
	- если есть необходимость хранить ссылки на объекты, но при этом важно, чтобы эти ссылки не влияли на время жизни объектов, то для этого можно использовать `Weak<T>`

---

## Interior Mutability Pattern

#### Motivation

В основе философии безопасности языка `Rust` лежат строгие правила владения и заимствования.

Фундаментальное правило заимствования гласит: ***в любой момент времени конкретный ресурс может быть заимствован либо через единственную мутабельную ссылку (`&mut T`), либо через произвольное множество иммутабельных ссылок (`&T`)***.

В этом правиле важно понимать взаимоисключаемость этих вариантов. Это правило значительно помогает решить многие проблемы в разных аспектах языка, например предотвратить гонки данных на этапе компиляции.

Однако эта строгость также имеет накладные расходы и создаёт трудности в некоторых ситуациях. Представим сценарий: пусть мы имеем некоторую структуру, которую мы заимствовали через иммутабельную ссылку в каком-то контексте, но нам необходимо мутировать некоторую часть её внутреннего состояния. Согласно фундаментальным правилам заимствования, имея `&T`, мы не можем получить `&mut T` к полям данной структуры. Компилятор справедливо запретит это, так как это нарушило бы гарантию отсутствия одновременного неизменяемого доступа и мутации.


Как же решить эту дилемму? Нужно ли перестраивать всю архитектуру, чтобы избежать таких ситуаций? Не всегда. А всё потому, что в `Rust` есть элегантное решение через паттерн, известный как `Interior Mutability`.

#### Concept 

И так, определим этот паттерн. `Interior mutability` - это паттерн проектирования в `Rust`, который позволяет мутировать ресурс даже при наличии иммутабельных ссылок на него. Достигается это за счёт того, что проверка правила заимствования переносится с этапа компиляции на этап выполнения (`runtime`) или за счёт использования механизмов, которые обходят необходимость традиционного заимствования для определённых операций.

Этот паттерн реализуется с помощью специальных типов-обёрток, находящихся в модуле `std::cell`. Основными представителями этого семейства являются `Cell<T>` и `RefCell<T>`. Они инкапсулируют ресурс (`T`) и предоставляют `API` для его мутации через разделяемую (неизменяемую) ссылку на саму обёртку.

### [Cells](https://cheats.rs/#cells)

Фундаментальным строительным блоком для этого семейства обёрток служит тип `UnsafeCell<T>`, который является единственным способом в безопасной области видимости "легально" получить `&mut T` из `&T`. Однако его прямое использование требует блока `unsafe`. Типы `Cell<T>` и `RefCell<T>` предоставляют безопасные абстракции поверх `UnsafeCell<T>`.

``` Rust
pub struct Cell<T> {
    value: UnsafeCell<T>,
}
```


### `Cell<T>`

`Cell<T>` представляет собой простейший механизм внутренней изменяемости. Однако он определён только для типов, имплементирующих трейт `Copy`. 

С помощью метода `get()` он позволяет получить копию внутреннего объекта типа `T`. А с помощью метода `set()` он предоставляет возможность заменить внутреннее значение на новое. При этом важно понимать, что `Cell<T>` не предоставляет ссылок на внутренний ресурс. Метод `get()` возвращает именно копию. 

То есть так как `Cell<T>` не предоставляет ссылок на внутренний ресурс, он может нарушать правила заимствования традиционным способом.

Также важно подметить, что `Cell<T>` не является потокобезопасным `!Sync` (его нельзя разделять между потоками через `&Cell<T>`)

Таким образом, `Cell<T>` идеально подходит для простых сценариев, таких как:

- счётчики или флаги внутри структуры, которая передаётся по иммутабельной ссылке.
- управление простым состоянием в замыканиях, захватывающих окружение по иммутабельной ссылке.
- Манипулирование простыми типами данных (`Copyable`), где операция сводится к получению копии или полной замене состояния.

Рассмотрим основную пользу этого типа на примере:

``` Rust
use std::cell::{Cell, RefCell};
use std::collections::HashMap;
use std::time::{Instant, Duration};

/// Cache with performance metrics
struct Cache {
    // Simple counters - using Cell
    hit_count: Cell<u32>,
    miss_count: Cell<u32>,
    
    // Cache data storage - using RefCell
    storage: RefCell<HashMap<String, (String, Instant)>>,
    
    // Configuration (ttl) - also Cell since it's a simple value
    default_ttl: Cell<Duration>,
}

impl Cache {
    /// Get value from cache
    fn get(&self, key: &str) -> Option<String> {
        let mut storage = self.storage.borrow_mut();
        
        if let Some((value, timestamp)) = storage.get(key) {
            if timestamp.elapsed() < self.default_ttl.get() {
                self.hit_count.set(self.hit_count.get() + 1);
                return Some(value.clone());
            }
            // Remove expired entry
            storage.remove(key);
        }
        
        self.miss_count.set(self.miss_count.get() + 1);
        None
    }
    
    /// Add value to cache
    fn set(&self, key: String, value: String) {
        let mut storage = self.storage.borrow_mut();
        storage.insert(key, (value, Instant::now()));
    }

	/// Update TTL for all new entries
	fn update_ttl(&self, new_ttl_seconds: u64) {
        self.default_ttl.set(Duration::from_secs(new_ttl_seconds));
    }
	// ...    
}

fn main() {
    // Create cache with TTL = 2 seconds
    let cache = Cache::new(2);
    
    // Add data
    cache.set("user:1".to_string(), "Alice".to_string());
    cache.set("user:2".to_string(), "Bob".to_string());
    
    // Read data (should get values)
    println!("user:1 = {:?}", cache.get("user:1")); // Some("Alice")
    println!("user:2 = {:?}", cache.get("user:2")); // Some("Bob")
    
    // Wait 3 seconds (longer than TTL)
    std::thread::sleep(Duration::from_secs(3));
    
    // Now data should be expired
    println!("user:1 = {:?}", cache.get("user:1")); // None
    println!("user:2 = {:?}", cache.get("user:2")); // None
    
    // Check statistics
    println!("Stats: {:?}", cache.stats()); // (2, 2) - 2 hits, 2 misses

    // Clear cache
    cache.clear();
    println!("After clear: {:?}", cache.get("user:3")); // None
}
```

То есть в данном примере состояния кеша: счётчики попаданий/промахов `hit_count`, `miss_count`, а также время жизни кеша `default_ttl` можно изменять, даже несмотря на то, что сами методы структуры принимают объект по иммутабельной ссылке.

**Вывод:** `Cell<T>` применим в примитивных однопоточных сценариях, где необходимо мутировать внутренние `copyable`-состояния составного типа, при этом не заимствуя сам тип через мутабельную ссылку.

### `RefCell<T>`

Мы разобрали одно и решений в виде типа `Cell<T>`, однако что же делать в многопоточном сценарии, а также в случаях, где внутренний ресурс `non-copyable` (`!Copy`)? В этом случае на помощь приходит его приятель `RefCell<T>`.

`RefCell<T>` достаточно отличается от `Cell<T>` механизмом разрешения `interior mutability`. Во-первых, `RefCell<T>` позволяет заимствовать внутренний ресурс на этапе выполнения (`runtime`). То есть в отличии от механизма `borrow checker`, который происходит на этапе компиляции, `RefCell<T>` выполняет проверки базовых правил заимствования на этапе выполнения.

Этот механизм определяется через методы `borrow()` и `borrow_mut()` для получения иммутабельной и мутабельной ссылки соответственно.

- `borrow()`: Успешно возвращает обёртку `Ref<T>` (которая преобразуется в `&T`), если в данный момент нет активных мутирующих заимствований. Увеличивает счётчик неизменяемых заимствований. В случае, если уже присутствует активное мутирующее заимствование, вызов `borrow()` вызывает панику `(panic!)`.

- `borrow_mut()`: Успешно возвращает обёртку `RefMut<T>` (которая преобразуется в `&mut T`), если в данный момент **нет никаких** активных заимствований (мутирующих и немутирующих). А также устанавливает **флаг мутирующего заимствования**. Аналогично вызывает панику, если при вызове уже есть какое-либо активное заимствование ресурса.

То есть не смотря на то, что проверки откладываются на этап выполнения, `RefCell` все равно обеспечивает безопасность ресурса, но достигается это за счёт того, что методы этого типа могут вызвать панику, если правила заимствования так и не были выполнены. И это может сыграть злую шутку, так как ошибки выполнения определить сложнее, чем ошибки компиляции.


Выше было указано, что методы `borrow()` и `borrow_mut()` возвращают не классические ссылки, а умные указатели `Ref<T>` и `RefMut<T>`. Эти типы имплементируют трейты `Deref`/`DerefMut`, позволяя их в тех же сценариях, что и обычные ссылки. Однако также они имплементируют `Drop`, что обеспечивает идиому `RAII`: в ситуации, где `Ref<T>`/`RefMut<T>` выходят из области видимости, они автоматически уменьшают счётчик заимствований или снимают флаг мутирующего заимствования в `RefCell`.

Существуют методы `try_borrow()` и `try_borrow_mut()`, которые возвращают `Result<Ref<T>` и `Result<RefMut<T>`, соответственно. Они позволяют проверить возможность заимствования без риска паники, возвращая `Err`, если правила заимствования нарушены.

Также, в отличии от `Cell`, `RefCell` не накладывает требований на копируемость ресурса (не требует, чтобы `T` имплементировал `Copy`).

А вот что касается потокобезопасности, `RefCell<T>` также `!Sync`. Его внутренние счётчики заимствования не атомарны, и попытка разделить `&RefCell<T>` между потоками приведёт к ошибке компиляции (если `T: !Sync`). Это и объясняет существование таких типов как `Mutex<T>` и `RwLock<T>`, которые также будут разобраны. 

И так, `RefCell` используется в сценариях, где:

- Необходима внутренняя изменяемость для некопируемых типов.
- Требуется получить временную ссылку (`&T`/`&mut T`) на внутренний ресурс для сложных операций.


``` Rust
use std::cell::{RefCell, Ref, RefMut};
use std::rc::Rc; 

struct DataHolder {
    data: RefCell<Vec<i32>>,
}

impl DataHolder {
    fn get_data(&self) -> Ref<Vec<i32>> {
        self.data.borrow()
    }

    fn get_data_mut(&self) -> RefMut<Vec<i32>> {
        self.data.borrow_mut()
    }

    fn add_element(&self, element: i32) {
        self.data.borrow_mut().push(element);
    }
}

fn main() {
    let holder = Rc::new(DataHolder {
        data: RefCell::new(vec![1, 2, 3]),
    });

    let holder_ref1 = Rc::clone(&holder);
    let holder_ref2 = Rc::clone(&holder);

    println!("Adding element via holder_ref1...");
    holder_ref1.add_element(4);

    println!("Reading data via holder_ref2:");
    let data_ref = holder_ref2.get_data();
    
    for item in data_ref.iter() {
        println!(" - {}", item);
    }
    let mut mutable_borrow = holder.get_data_mut();
    println!("Modifying data directly...");
}
```

Таким образом, оба этих типа позволяют обходить правила `borrow checker`, что может выручить в определённых сценариях. Однако следует помнить о **принципе наименьших привилегий**: стандартные правила владения и заимствования, проверяемые компилятором, всегда предпочтительнее, так как они обеспечивают самые сильные гарантии на этапе компиляции. 

Внутреннюю изменяемость стоит применять обдуманно, только тогда, когда статическая модель действительно не подходит или чрезмерно усложняет код.

---
## `RwLock<T>` && `Mutex<T>`

Ранее мы рассмотрели типы `Rc<T>` и `Arc<T>`, которые позволяют реализовать разделяемое владение ресурсом. Однако они по своей природе предоставляют лишь иммутабельный доступ к этому ресурсу. Это фундаментальное ограничение необходимо для предотвращения гонок данных (`data races`) - ситуаций, в которых несколько потоков одновременно обращаются к одним и тем же данным и хотя бы один из них ведёт модификацию ресурса. Гонки данных ведут к неопределённому поведению и являются одним из самых коварных источников ошибок в параллельной среде.

Но что, если нам действительно необходимо, чтобы несколько потоков могли не только читать, но и изменять одни и те же данные? Например, общий счетчик, обновляемый разными рабочими потоками, или разделяемый кеш, который нужно периодически обновлять. Просто обернуть изменяемые данные в `Arc<T>` недостаточно — компилятор справедливо запретит получение `&mut T` через `Arc<T>`, так как это нарушит гарантии безопасности.

Здесь на сцену выходят **примитивы синхронизации**, предоставляемые стандартной библиотекой `Rust` (в модуле `std::sync`). Они позволяют управлять доступом к разделяемым данным таким образом, чтобы гарантировать отсутствие гонок данных, даже если данные изменяются. Два наиболее важных примитива такого рода — это `Mutex<T>` и `RwLock<T>`.

Важно помнить: чтобы сам примитив синхронизации (`Mutex` или `RwLock`) мог быть доступен из нескольких потоков, его обычно оборачивают в `std::sync::Arc<T>`. Это обеспечивает разделяемое владение этими примитивами с потокобезопасным подсчетом ссылок. Таким образом, канонический паттерн для разделяемого изменяемого состояния — это `Arc<Mutex<T>>` или `Arc<RwLock<T>>`.

Теперь отдельно разберём каждый из этих примитивов.

### `Mutex<T> (Mutual exclusion)` 

[`Mutex`](https://doc.rust-lang.org/std/sync/struct.Mutex.html) - это один из старейших и наиболее фундаментальных примитивов синхронизации, обеспечивающий эксклюзивный доступ к внутреннему ресурсу `T`. Ключевая идея мьютекса заключается в том, что в каждый момент времени только один поток может иметь доступ к защищаемому ресурсу. Все остальные потоки, запрашивающие доступ должны ожидать освобождения мьютекса.
Таким образом, `Mutex` по своей природе сериализует доступ к защищаемым данным. Только один поток может находиться в критической секции (часть программы между `lock()` и `drop(guard)`) в каждый момент времени.


``` Rust
pub struct Mutex<T: ?Sized> {
    inner: sys::Mutex,
    poison: poison::Flag,
    data: UnsafeCell<T>,
}
```

#### Functionality

Фактически, мьютекс определяется двумя основными методом, а именно `lock()` и `unlock`. Достаточно будет разобраться с `lock()`, так как `unlock()` является его логической противоположностью. 

Метод `lock()` определяет получение потоком доступа к защищаемому ресурсу, инкапсулированному в мьютекс. Таким образом, поток, вызывающий этот метод, блокирует этот мьютекс для других потоков, защищая ресурс, инкапсулированный в него.

Если же мьютекс в данный момент свободен, текущий поток немедленно его захватывает. Если же уже мьютекс захвачен другим потоком, вызывающий поток блокируется. Это означает, что выполнение потока приостанавливается до тех пор, пока мьютекс не будет освобождён тем потоком, который его удерживает.

Успешный вызов метода `lock()` возвращает не просто ссылку `&mut T`, а специальный тип-обёртку `MutexGuard<T>`. Он имплементирует трейты `Deref` и `DerefMut`, что позволяет обращаться к внутреннему ресурсу через разыменование или напрямую вызывать методы аналогично вызову через мутабельную ссылку `&mut T`. Также, `MutexGuard<T>` имплементирует трейт `Drop`, реализуя этим механизм `RAII`. Это обеспечивает безопасное освобождение мьютекса даже в случае ошибок или паники, что предотвращает перманентную блокировку ресурса (`deadlock`).

Также существует метод `try_lock()`, который пытается захватить мьютекс, но, в отличие от `lock()`, не блокирует поток в случае неудачи. Он немедленно возвращает `Result`, где `Ok(MutexGuard<T>)` означает успешный захват, а `Err(TryLockError::WouldBlock)` – что мьютекс уже занят. `Err(TryLockError::Poisoned(_))` сигнализирует об отравлении.

#### `Poisoning`

На самом деле `lock()` возвращает чуть больше, чем просто `MutexGuard`. В действительности возвращаемым типом является `LockResult<MutexGuard<'_, T>>`. `LockResult` же из себя представляет обёртку над `Result`, определённую специально для мьютекса и `RwLock`.

``` Rust
pub type LockResult<T> = Result<T, PoisonError<T>>;
```

`PoisonError` из себя представляет тип ошибки, связанной с "отравлением" (`Poisoning`).

`Poinsoning` - это сценарий, происходящий в случае, если поток, удерживающий блокировку, паникует. В этом случае, `Mutex` или `RwLock` помечаются "отравленными", что сигнализирует о том, что ресурс мог остаться в несогласованном состоянии. Это предотвращает последующее непредсказуемое поведение, так как после пометки, последующие вызовы `lock()` будут возвращать `Err`, предотвращая работу с потенциально повреждённым ресурсом.

#### `Thread-safety`

Что же обеспечивает мьютексу потокобезопасность? Конечно, на уровне ядра операционной системы это обеспечивает `inner: sys::Mutex`. Однако также это обеспечивается и благодаря трейтам `Send` и `Sync`. 

На самом деле всё просто: `Mutex<T>` имплементирует трейт `Sync`, если тип `T` имплементирует трейт `Send`. Это означает, что ссылку `&Mutex<T>` можно безопасно разделять между потоками (обычно через `Arc`). Важно понимать, что сам ресурс `T` не обязан быть `Sync`. Почему? Потому что `Mutex` гарантирует, что в любой момент времени доступ к `T` имеет только один поток (через `&mut T`, предоставляемый `MutexGuard`), следовательно, одновременного доступа к `T` из разных потоков через разделяемые ссылки (`&T`) не происходит. Ограничение на тип `T`: `Send` необходимо, так как владение ресурсом `T` может "перемещаться" между потоками по мере захвата и освобождения мьютекса.


#### Overhead

Однако, блокировки потоков достаточно сильно снижает уровень параллелизма системы, а также повышает риск взаимоблокировок.

Например, при использовании нескольких мьютексов, неправильный порядок их захвата разными потоками может привести к этой самой взаимоблокировке (`Deadlock`) - ситуации, в которой два или более потока бесконечно ожидают друг друга для освобождения ресурса.

Также важно понимать, что методы `lock` и `unlock` требуют системных вызовов или атомарных операций процессора, что влечёт за собой накладные расходы, особенно при высокой **контенции** (`contention`) - частом одновременном запросе мьютекса несколькими потоками.

#### Summary

Итак, мы выяснили, что мьютекс является практически универсальным решением для защиты разделяемого ресурса в конкурентной среде. 

Приведём наглядный пример, показывающий безопасное разделение счётчика между потоками:

``` Rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    // i32 implements Send, hence Mutex<i32> implements Sync.
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        // cloning Arc => ref_count++
        let counter_clone = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num_guard = counter_clone.lock().unwrap();

            // dereference from MutexGuard<i32> to &mut i3.
            *num_guard += 1;

            // MutexGuard goes out of scope => drop()
        });
        handles.push(handle);
    }

    // waiting for threads to complete
    for handle in handles {
        handle.join().unwrap();
    }

    // check final value
    let final_value = *counter.lock().unwrap();
    println!("Final counter value: {}", final_value); 
    //expexted value: 10
}
```

---
### `RwLock (Read-Write Lock)`

`Mutex<T>` обеспечивает строгую гарантию эксклюзивного доступа, что идеально подходит для операций мутации ресурса (записи). Однако, если данные чаще читаются, чем изменяются, `Mutex` становится узким местом: он не позволяет даже нескольким потокам-читателям работать параллельно, несмотря на то, что операции чтения сами по себе часто безопасны для параллельного выполнения. На помощь приходит `RwLock`.

`RwLock` также является примитивом синхронизации и он предлагает более гибкую модель для сценариев "частое чтение, редкая запись". Благодаря этому несколько потоков могут параллельно удерживать блокировку на чтение (`read lock`).

Эта семантика позволяет читающим потокам работать параллельно, не блокируя друг друга, но требует, чтобы пишущий поток дождался завершения всех текущих операций (как чтения, так и записи) и затем получил монопольный доступ к ресурсу. ***Следовательно, инвариантом `Rwlock` является состояние, в котором читающие и пишущие потоки никогда не сосуществуют.***

#### Functionality

``` Rust
pub struct RwLock<T: ?Sized> {
    inner: sys::RwLock,
    poison: poison::Flag,
    data: UnsafeCell<T>,
}
```


Интерфейс `RwLock` предоставляет методы для запроса соответствующего типа доступа:

1. `read()` -> `Result<RwLockReadGuard<T>, PoisonError<RwLockReadGuard<T>>>`. Этот метод запрашивает блокировку на чтение, атомарно проверяя состояние. Если блокировка записи неактивна (и, в зависимости от политики реализации, нет ожидающих писателей с высоким приоритетом), блокировка чтения предоставляется немедленно, а счётчик читателей атомарно инкрементируется. Однако, если же активна блокировка записи (или ждет приоритетный писатель), вызывающий поток **блокируется** до тех пор, пока не станет возможным предоставить блокировку чтения. В случае успеха метод возвращает `Ok(RwLockReadGuard<T>)`. Этот тип имплементирует трейт `Deref<Target = T>`, предоставляя доступ к ресурсу `T` через иммутабельную ссылку `&T`. При выходе `RwLockReadGuard` из области видимости (`Drop`), блокировка чтения автоматически освобождается.
        
2. `write()` -> `Result<RwLockWriteGuard<T>, PoisonError<RwLockWriteGuard<T>>>`. Этот метод запрашивает эксклюзивную блокировку на запись, также атомарно проверяя состояние. Если никаких блокировок (ни чтения, ни записи) в данный момент нет, блокировка записи предоставляется немедленно и атомарно устанавливает флаг записи. Если активна любая блокировка (чтения или записи), вызывающий поток **блокируется** до тех пор, пока все текущие блокировки не будут освобождены. В случае успеха возвращает `Ok(RwLockWriteGuard<T>)`. Этот тип аналогично имплементирует трейт `Deref<Target = T>` и `DerefMut<Target = T>`, предоставляя доступ к данным через мутабельную ссылку `&mut T`. При выходе `RwLockWriteGuard` из области видимости (`Drop`), блокировка записи автоматически освобождается.
        
3. `try_read() / try_write()`: Неблокирующие версии, которые пытаются захватить блокировку и немедленно возвращают `Result`, указывающий на успех (`Ok(Guard)`) или причину неудачи (`Err(TryLockError::WouldBlock)` или `Err(TryLockError::Poisoned)`).


Хотя конкретная реализация `RwLock` может зависеть от операционной системы и версии стандартной библиотеки, концептуально она должна управлять несколькими ключевыми аспектами состояния и поведения:

- RwLock должен знать, находится ли он в одном из следующих состояний:

	- **Unlocked:** Нет активных блокировок.
    
	- **Read-Locked:** Одна или несколько блокировок чтения активны. Необходимо отслеживать количество активных читателей.
    
	- **Write-Locked:** Одна блокировка записи активна.

- Изменение состояния (например, увеличение счетчика читателей, установка флага записи) должно выполняться **атомарно**. Это предотвращает гонки данных внутри самой реализации `RwLock`, когда несколько потоков одновременно пытаются изменить его состояние. Для этого используются атомарные инструкции процессора (например, `compare-and-swap`, `atomic increments/decrements`), часто абстрагированные через тип `std::sync::atomic::AtomicUsize` или аналогичные.


#### Poisoning


Механизм "отравления" в `RwLock` работает немного иначе, чем в `Mutex`:

- `RwLock` считается отравленным, только если поток **паникует во время удержания блокировки на запись (`RwLockWriteGuard`)**.
    
- Паника потока во время удержания блокировки на чтение (`RwLockReadGuard`) **не** отравляет `RwLock`. Логика здесь в том, что операция чтения не должна была изменять ресурс, поэтому его состояние предполагается согласованным.
    
- Последующие вызовы `read()` или `write()` на отравленный `RwLock` вернут `Err(PoisonError)`.

#### `T: Sync + Send`


Для того чтобы `RwLock<T>` сам имплементировал трейт `Sync`, позволяя безопасно разделять ссылки `&RwLock<T>` между потоками, необходимо, чтобы инкапсулированный тип `T` удовлетворял двум фундаментальным требованиям безопасности в контексте многопоточности: он должен имплементировать трейты `Send` и `Sync` (`T: Send + Sync`). Рассмотрим обоснование для каждого из этих ограничений.

1. `Sync`: Типаж `Sync` является маркером для типов, ссылки на которые (`&T`) можно безопасно разделять между потоками. Механизм `RwLock` по своей конструкции предоставляет метод `read()`, который позволяет множеству потоков одновременно получать доступ к инкапсулированному ресурсу `T`. Этот доступ осуществляется через тип-обёртку `RwLockReadGuard<T>`, который имплементирует трейт `Deref<Target = T>`, предоставляя иммутабельную ссылку `&T`. Следовательно, использование `RwLock` в режиме чтения создает ситуацию, когда ссылки `&T` могут одновременно существовать и использоваться в разных потоках. Для обеспечения безопасности такой операции сам тип `T` должен быть пригоден для разделяемого доступа из разных потоков, что формально выражается требованием `T: Sync`. В противном случае, одновременный доступ к `&T` из разных потоков был бы неопределенным поведением (`Undefined Behavior`).
    
2. `T: Send`: Трейт `Send` является маркером для типов, значения которых можно безопасно передавать (перемещать владение) между потоками. Хотя `RwLock<T>` не перемещает само значение `T`, его метод `write()` предоставляет эксклюзивный доступ к `T` через обёртку `RwLockWriteGuard<T>`, который имплементирует `DerefMut<Target = T>`, давая мутабельную ссылку `&mut T`. Критически важно, что право на получение этой изменяемой ссылки может быть последовательно предоставлено различным потокам в течение времени жизни `RwLock`. То есть, Поток `А` может захватить блокировку записи, получить `&mut T`, произвести модификации, освободить блокировку; позже Поток `B` может сделать то же самое. Эта возможность для различных потоков получить `&mut T` к одному и тому же значению `T` (хотя и не одновременно) требует, чтобы тип `T` был безопасен для такого "переноса" возможности мутации между потоками. Трейт `Send` гарантирует именно это: он подтверждает, что тип `T` не содержит ресурсов или состояний (например, неатомарных счетчиков ссылок типа `Rc`), которые сделали бы небезопасным получение и использование `&mut T` в потоке, отличном от того, где `T` мог быть изначально создан или ранее использован.


#### Usage 

Рассмотрим наглядный пример использования `RwLock`:

``` Rust
┌──────────────────────┐       ┌──────────────────────┐
│   Config Manager     │       │     Web Server       │
│                      │       │                      │
│  ┌────────────────┐  │       │  ┌────────────────┐  │
│  │  RwLock<Config>│◄─┼───────┼──┤ Request Handler│  │
│  └────────────────┘  │       │  └────────────────┘  │
│           ▲          │       │           ▲          │
│           │          │       └───────────┼──────────┘
│  ┌────────┴────────┐ │                   │
│  │ Config Reloader │ │         ┌─────────┴─────────┐
│  └─────────────────┘ │         │   Metrics Logger  │
└──────────┬───────────┘         └───────────────────┘
           │
┌──────────▼───────────┐
│   Config File        │
│   (config.toml)      │
└──────────────────────┘


use std::sync::{Arc, RwLock};
use std::time::{Duration, Instant};
use std::thread;
use std::fs;
use serde::Deserialize;
use metrics::{counter, gauge};
use anyhow::{Result, Context};

#[derive(Debug, Deserialize, Clone)]
pub struct AppConfig {
    pub server_port: u16,
    pub db_url: String,
    pub cache_ttl: Duration,
    pub rate_limit: Option<u32>,
    pub feature_flags: FeatureFlags,
}

#[derive(Debug, Deserialize, Clone)]
pub struct FeatureFlags {
    pub enable_search: bool,
    pub experimental_api: bool,
}

pub struct ConfigManager {
    inner: Arc<RwLock<AppConfig>>,
    last_modified: Arc<RwLock<Instant>>,
    file_path: String,
}

impl ConfigManager {
    pub fn new(file_path: &str) -> Result<Self> {
        let config = Self::load_config(file_path)?;
        Ok(Self {
            inner: Arc::new(RwLock::new(config)),
            last_modified: Arc::new(RwLock::new(Instant::now())),
            file_path: file_path.to_string(),
        })
    }

    fn load_config(file_path: &str) -> Result<AppConfig> {
        let config_str = fs::read_to_string(file_path)
            .context("Failed to read config file")?;
        toml::from_str(&config_str)
            .context("Failed to parse config file")
    }

    pub fn get_config(&self) -> AppConfig {
        // Fast path for reading
        let config = self.inner.read()
            .expect("RwLock poisoned");
        config.clone()
    }

    pub fn reload(&self) -> Result<()> {
        // Check file modification time
        let metadata = fs::metadata(&self.file_path)?;
        let modified = metadata.modified()?;
        
        {
            let last_modified = self.last_modified.read()?;
            if modified <= last_modified.duration_since(UNIX_EPOCH) {
                return Ok(());
            }
        }

        // Slow path for writing
        let new_config = Self::load_config(&self.file_path)?;
        {
            let mut config = self.inner.write()
                .context("Failed to acquire write lock")?;
            *config = new_config;
            
            let mut last_modified = self.last_modified.write()?;
            *last_modified = Instant::now();
        }

        counter!("config.reloads", 1);
        Ok(())
    }

    pub fn start_reloader(self: &Arc<Self>, interval: Duration) {
        let manager = Arc::clone(self);
        thread::spawn(move || {
            loop {
                thread::sleep(interval);
                if let Err(e) = manager.reload() {
                    log::error!("Config reload failed: {}", e);
                    counter!("config.reload_errors", 1);
                }
            }
        });
    }
}

// Example usage in web server
pub struct WebServer {
    config_manager: Arc<ConfigManager>,
}

impl WebServer {
    pub fn handle_request(&self, path: &str) -> String {
        let config = self.config_manager.get_config();
        
        // Record metrics
        gauge!("server.active_requests", 1.0);
        defer!(gauge!("server.active_requests", -1.0));
        
        // Use config values
        if path == "/experimental" && !config.feature_flags.experimental_api {
            return "Feature disabled".to_string();
        }
        
        format!("Serving request on port {}", config.server_port)
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize
    let config_manager = Arc::new(ConfigManager::new("config.toml")?);
    config_manager.start_reloader(Duration::from_secs(30));
    
    // Simulate web server
    let server = WebServer { config_manager };
    
    // Benchmark
    let start = Instant::now();
    let handles: Vec<_> = (0..1000).map(|i| {
        let server = server.clone();
        tokio::spawn(async move {
            server.handle_request(&format!("/req/{}", i))
        })
    }).collect();
    
    for handle in handles {
        let _ = handle.await?;
    }
    
    println!("Completed in {:?}", start.elapsed());
    Ok(())
}
```


Приведённый пример наглядно показывает, что `RwLock` идеально подходит для сценариев, где чтение конфигурации происходит часто (при каждом запросе), а запись - редко (например по таймеру). Все потому, что использование `RwLock` гарантирует, что читающие потоки всегда видят согласованное состояние конфигурации (либо старое, либо модифицированное) и что операция записи является атомарной по отношению к читателям. 