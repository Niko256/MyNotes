
[Borrow checker](https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src/libcore/borrow.rs) - это механизм в языке Rust, который на этапе компиляции проверяет соблюдение правил заимствования в исходном коде.

Для понимания работы этого механизма, для начала необходимо разобраться с базовыми понятиями.

---
## Ownership 

**Владение (ownership)** - это гарантия ответственности за управление ресурсом объекта. Каждый объект имеет только одного владельца в конкретный момент времени.

Владение возможно передавать между участками кода при помощи перемещения (move) или при помощи заимствования (borrowing). Владение можно передать переменной, функции или структуре, при этом после передачи предыдущий владелец перестаёт быть валидным (Если только тип не реализует трейт `Copy`). В момент когда владелец выходит из области видимости объекта, ресурс автоматически освобождается (только если он не был перемещён). Таким образом, владение гарантирует, что ресурс остаётся валидным до тех пор, пока владелец имеет к нему доступ.


---
## Borrowing

**Заимствование (borrowing)** - это явление временной передачи доступа к ресурсу объекта, без передачи прав владения. Заимствование создаёт ссылку на ресурс, которая имеет своё время жизни (lifetime), в течении которого ссылка остаётся валидной и доступ к ресурсу определён.

Заимствование бывает двух типов: неизменяемое (shared (`&`)) и изменяемое (mutable (`&mut`)).

***Правила заимствования:***

- В любой момент времени может существовать только одна изменяемая ссылка (`&mut T`), либо любое количество неизменяемых ссылок (`&T`). 

- Заимствования (ссылки) должны быть действительны в течении всего времени их использования.
	- => Ссылка не может пережить владельца объекта 

---

Как раз таки для проверки выполнения правил заимствования в `Rust` и существует механизм `borrow checker`.

То есть его работа позволяет отловить на этапе компиляции следующие ошибки, которые распостранены во многих языках программирования:

- `Data races` - ситуация, в которой несколько потоков одновременно читают и изменяют (пишут) одни и те же данные, приводя к неопределённым результатам

- `Use after free` - ситуация, в которой происходит обращение по адресу, который уже не является валидным (память была "освобождена")

- `Dangling pointers` - использование указателей или ссылок, указывающих на участок памяти, который больше не действителен

