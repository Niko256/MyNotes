Сегодня любая многозадачная операционная система создаёт иллюзию параллелизма для пользователя, путём быстрого переключения процессов с ядра процессора. Обеспечивается это за счёт подсистемы ядра операционной системы, называемой **Планировщиком** (Scheduler). В данном конспекте мы рассмотрим основные принципы, по которым работают планировщики в современных операционных системах.

Для чего вообще он нужен, какие проблемы он решает? 

Основной задачей планировщика является максимально эффективное распределение процессорных тактов между готовыми к выполнению процессами.


Многозадачность позволяет многим процессам блокироваться или "спать", не выполняясь, пока не появится необходимость.

Обычно, многозадачность разделяют на две основные части:

- Вытесняющая многозадачность (Preemptive multitasking)
- Кооперативная многозадачность (Cooperative multitasking)


### Preemptive multitasking

В вытесняющей многозадачности планировщик определяет момент, когда процесс должен прекратить выполняться. Поэтому и невольная приостановка выполняющегося процесса называется **вытеснением**.

Время, в течении которого процесс выполняется до вытеснения, называется ***квантом времени процесса***. Управление квантом времени позволяет планировщику принимать глобально управлять системой и предотвращать монополизацию процессорного времени одним процессом.

### Cooperative multitasking

Кооперативная многозадачность практически не используется в современных операционных системах, так как имеет ряд минусов по сравнению со своим аналогом.

В кооперативной многозадачности процесс не прекращает свою работу, пока не "решит" сделать это добровольно. Такая добровольная приостановка называется **уступкой**. Данное построение многозадачной операционной системы может привести к краху, ведь зависший процесс, который никогда не уступает может уничтожить всю многозадачность системы.

---
## Linux $O(1)$ Scheduler

В ходе разработки ядра Linux версии 2.5 был введён новый планировщик, известный как $O(1)$ из-за своего алгоритмического поведения.

Введение алгоритма с константным временем расчёта кванта времени процесса и очередей выполнения на каждом ядре процессора исправило ограничения дизайна предыдущего планировщика Linux. Новый планировщик стал легко масштабироваться на всё большее количество возможных процессов. Со временем стало очевидно, что $O(1)$ планировщик имел несколько патологических сбоев, связанных с задержками для чувствительных к задержкам приложений. К таким приложениям относятся интерактивные процессы, с которыми взаимодействует пользователь.


В ядре Linux 2.6 разработчики столкнулись с необходимостью улучшить интерактивную производительность существующего планировщика процессов $O(1)$. Это привело к появлению новых планировщиков, которые были нацелены на решение проблем, связанных с задержками и интерактивностью.

---
## Completely Fair Scheduler

В ядре версии 2.6.23 $O(1)$ scheduler был заменен на `Completely Fair Scheduler` (CFS).

`CFS` использует интрузивное красно-черное дерево для хранения и управления процессами. Это позволяет эффективно находить процесс, который должен быть запущен следующим. Также `CFS` использует концепцию виртуального времени `(vruntime)`, которая отражает сколько процессорного времени должен был бы получить процесс, если бы все процессы были равны.

Данный планировщик был частью ядра много лет и был заменён на `EEVF-scheduler` лишь в версии `6.6`.

---
## Policy

Набор правил, используемых для определения того, когда и как выбирать новый процесс для выполнения, называется **политикой планирования**. Политика планирования часто определяет общий характер работы системы и отвечает за оптимальное использование процессорного времени. Поэтому она очень важна.

В Linux планирование основано на технике разделения времени (time sharing).

Несколько процессов выполняются в режиме "разделения времени", так как процессорное время делится на кванты, по одному для каждого готового к выполнению процесса.

Однако, в любой момент времени на одном ядре процессора может выполняться только один процесс / поток. Если текущий выполняющийся процесс / поток не завершается, когда его квант времени (quantum) истекает, может произойти переключение процессов.

Разделение времени основано на прерываниях таймера и поэтому прозрачно для процессов.

**Политика планирования также основана на ранжировании процессов в соответствии с их приоритетом.**

Для определения текущего приоритета процесса иногда используются сложные алгоритмы, но конечный результат один: каждый процесс ассоциируется со значением, которое говорит планировщику, насколько целесообразно позволить процессу выполняться и занять процессорное время.


В Linux приоритет процесса является динамическим. Это означает, что планировщик следит за тем, что процесс / поток выполняет и в зависимости от этого меняет его приоритет.


При этом сами приоритеты разделяются на два диапазона:

- `nice-value` диапазон.
- `real-time` диапазон.


Диапазон `nice-value` значений представлен от -20 (наивысший приоритет) до 19 (наименьший приоритет). Пользователь может изменить `nice-value` процесса с помощью системных вызовов `nice` и `renice`. Чем ниже `nice-value`, тем выше приоритет процесса. Процессы с более низким `nice-value` получают больше процессорного времени.

Диапазон `real-time` значений представлен от 1 (наименьший приоритет) до 99 (наивысший приоритет). Процессы с приоритетом реального времени получают абсолютный приоритет над всеми остальными процессами, включая те, которые имеют `nice-value`. 


Когда процесс переходит в состояние `TASK_RUNNING`, ядро проверяет, превышает ли его динамический приоритет приоритет текущего выполняющегося процесса.

Если динамический приоритет нового процесса выше, выполнение текущего процесса прерывается, и вызывается планировщик для выбора другого процесса для выполнения.

Процесс также может быть вытеснен, когда истекает его квант времени. В этом случае устанавливается флаг `TIF_NEED_RESCHED` в структуре `thread_info` текущего процесса, и планировщик вызывается после завершения обработчика прерывания таймера.

---
## Quantum duration

**Длительность кванта времени (quantum duration)** является критически важным фактором для производительности системы: она не должна быть ни слишком длинной, ни слишком короткой.

Слишком длинный или слишком короткий квант времени может привести к неэффективному использованию ресурсов и снижению общей производительности.

Если квант времени слишком длинный, процессы, требующие быстрого отклика (например, интерактивные приложения или системные службы), будут испытывать значительные задержки.
Выполнение одного процесса в течение длительного времени снижает эффективность многозадачности, так как другие процессы будут простаивать в очереди ожидания.


Однако слишком частые переключения между процессами требуют значительных ресурсов процессора на сохранение и восстановление контекста выполнения. Это может привести к накладным расходам на переключение контекста (context switch overhead), которые могут существенно снизить производительность системы. Хотя короткий квант времени может улучшить отзывчивость системы, он может снизить общую пропускную способность, так как процессор будет тратить больше времени на переключение контекста, чем на фактическое выполнение процессов.


Некоторые операционные системы поддерживают **динамическую настройку кванта времени**, что позволяет адаптировать его длительность в зависимости от текущей рабочей нагрузки и требований системы. Например, система может увеличивать квант времени во время высокой нагрузки, чтобы повысить пропускную способность, и уменьшать его во время низкой нагрузки, чтобы улучшить отзывчивость.


Планировщик Linux всегда находит процесс для выполнения. Это означает, что даже в ситуациях, когда кажется, что нет готовых к выполнению процессов, система всегда имеет как минимум один такой процесс. Этот процесс называется `swapper process` и имеет `PID` 0. В многоядерных системах каждый процессор имеет свой собственный `swapper process` с `PID` 0. Это обеспечивает независимость планирования на каждом ядре процессора.


---
## Static and dynamic priorities of processes

Каждый обычный процесс в Linux имеет свой собственный ***статический приоритет***. Это значение используется планировщиком для оценки процесса относительно других обычных процессов в системе.

Статический приоритет представлен числом в диапазоне от 100 (наивысший приоритет) до 139 (наименьший приоритет). Важно отметить, что **чем выше значение, тем ниже приоритет**. При этом новый процесс всегда наследует статический приоритет своего родительского процесса.

Статический приоритет в значительной степени определяет **базовый квант времени** процесса, то есть длительность кванта времени, назначенную процессу, когда он исчерпал свой предыдущий квант времени.

Чем выше статический приоритет (то есть чем ниже его числовое значение), тем больше базовый квант времени.

Как и указывалось ранее, у процесса так же есть динамический приоритет в виде значения в промежутке от 100 (наивысший) до 139 (наименьший). Сам динамический приоритет можно определить как число, которое планировщик использует при выборе нового процесса для выполнения.

Динамический приоритет процесса пересчитывается каждый раз, когда процесс завершает свой квант времени или когда происходит событие, требующее перепланирования.

**Формула для расчета динамического приоритета:**

$$dynamic \ priority = max(100, \ min(static \ priority - bonus + 5,139))$$


- Бонус - это значение в диапазоне от 0 до 10. Значение меньше 5 представляет собой штраф, который снижает динамический приоритет, а значение больше 5 — премию, которая повышает динамический приоритет.
    
- Значение бонуса, в свою очередь, зависит от прошлой истории процесса; более конкретно, оно связано со **средним временем сна** процесса.

**Среднее время сна** — это среднее количество наносекунд, которое процесс провел во сне. Важно отметить, что это не простое среднее значение прошедшего времени. Например, время сна в состоянии `TASK_INTERRUPTIBLE` и `TASK_UNINTERRUPTIBLE` учитывается по-разному.

Среднее время сна уменьшается, когда процесс выполняется. При этом оно никогда не может превышать 1 секунду.

В конечном итоге, определение среднего значения сна процесса помогает планировщику правильно балансировать нагрузку на систему. На основе этого параметра он может определить, является ли процесс интерактивным, определять динамический приоритет и другие параметры, которые в итоге влияют на распределение процессорного времени между процессами или потоками.

---
## vruntime

**vruntime** (virtual runtime) — это виртуальное время выполнения,являющееся одним из ключевых параметров, которое используется в алгоритме планирования процессов.

vruntime корректируется с учетом приоритета процесса. Процессы с более высоким приоритетом получают меньшее vruntime за то же самое время выполнения на процессоре, чем процессы с более низким приоритетом.

CFS хранит процессы в красно-черном дереве, отсортированном по их vruntime. Это позволяет быстро находить процесс с наименьшим vruntime.

Каждый раз, когда процесс завершает свой квант времени или блокируется, его vruntime обновляется, исходя из его обновлённого динамического приоритета. Если процесс продолжает выполняться, его vruntime увеличивается пропорционально времени, проведенному в выполнении.


Предположим, у нас есть два процесса:

- **Процесс A** с приоритетом 120 (вес = 1024).
    
- **Процесс B** с приоритетом 100 (вес = 820).
    

Если оба процесса выполняются в течение 10 мс:

- Процесс A:

$$vruntime_{A} = 10 mc \ \cdot\frac{1024}{1024} = 10 mc $$

- Процесс B:
    $$vruntime_{B} = 10mc \cdot \frac{1024}{820} ≈ 12.49 mc$$
    
Таким образом, несмотря на то, что оба процесса выполнялись одинаковое время, vruntime процесса `B` будет больше, чем у процесса `A`, из-за его более высокого приоритета.

---
## Active and expired processes 

Даже если процессы с более высоким статическим приоритетом получают большие кванты процессорного времени, они не должны полностью блокировать процессы с более низким статическим приоритетом. Чтобы избежать **голодания процессов** (process starvation), процесс может быть заменен процессом с более низким приоритетом, чей квант времени еще не исчерпан.

Для реализации этого механизма планировщик поддерживает два непересекающихся набора готовых к выполнению процессов:

1. **Активные процессы (Active processes):**
    
    - Эти готовые к выполнению процессы еще не исчерпали свой квант времени и, следовательно, могут продолжать выполняться.
        
    - Планировщик выбирает процессы из этого набора для выполнения.
        
2. **Истекшие процессы (Expired processes):**
    
    - Эти готовые к выполнению процессы уже исчерпали свой квант времени и, следовательно, запрещены к выполнению до тех пор, пока все активные процессы не истекут.
        
    - Планировщик не выбирает процессы из этого набора для выполнения, пока не закончатся все активные процессы.

---
## Runqueue

`Runqueue` — это наиболее важная структура данных в планировщике. Каждое ядро процессора в системе имеет свою собственную `runqueue`. 

Runqueue содержит список потоков, которые готовы к выполнению на ядре, но еще не запущены. Каждый готовый к выполнению процесс в системе принадлежит одной и только одной `runqueue`. 

Пока готовый процесс остается в той же `runqueue`, он может выполняться только ядром процессора, владеющим этой `runqueue`.
Однако, готовые к выполнению процессы могут мигрировать из одной `runqueue` в другую.

Также данная структура содержит другие важные параметры, такие как фактор загрузки `CPU`, количество переключений процессов и указатели на текущий и `swapper` процессы.

На данной диаграмме можно увидеть примерное устройство данной структуры

![runqueue|600](https://i.imgur.com/7wqt5fi.jpeg)

При этом каждому из ядер в системе необходимо проверять свою нагрузку относительно других ядер системы. То есть ядра должны балансировать нагрузку.

Балансировка бывает **Активной** и **Пассивной**:

- Активная балансировка: Перегруженное ядро (относительно остальных ядер) активно пытается "вытолкнуть" задачу на менее загруженное ядро.
- Пассивная балансировка: Ядро, которое недогружено, пассивно запрашивает задачи у более загруженных ядер.

Алгоритмы балансировки нагрузки выбирают задачи для миграции на основе разных эвристик.


---

## `EEVDF`

**Earliest Eligible Virtual Deadline First** - это планировщик, который заменил `CFS` в версии ядра `6.6`.

Детально разберём нововведения и основные особенности данного планировщика.

Во-первых, данный планировщик привнёс концепцию `virtual deadline`. Каждой задаче в системе присваивается `virtual deadline`, который представляет из себя момент, к которому данная задача должна получить выделенный квант `CPU` (если бы система была идеально справедливой). Задачи с наименьшими виртуальными дедлайнами имеют наивысший приоритет

---

// [link](https://disk.yandex.ru/i/LsgIsh8fuWRLew)

