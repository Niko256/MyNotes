`Socket` - это один из основных механизмов межпроцессного взаимодействия (`IPC`), который предоставляет возможность двунаправленного обмена данными между процессами, как в рамках одной машины (`Unix domain sockets`), так и по сети.

**В `Unix`-подобных системах открытые сокеты имеют статус "файла" и   представляются файловыми дескрипторами**. 

Однако это представление легче понимать как отображение между идентификатором сокета (файловым дескриптором) и самим экземпляром структуры `sock`, представленным в ядре операционной системы. 

Структура `sock` хранит в себе всю необходимую информацию о сокете, включая адреса, порты, состояние соединения и буфферы данных.

Каждый процесс в операционной системе хранит таблицу файловых дескрипторов как часть контекста. Эта таблица представляет из себя массив указателей на структуру `file`. 

Когда процесс создаёт сокет с помощью системного вызова `socket()`, ядро выделяет память для структуры `sock` и связывает её с соответствующей структурой `socket`. При этом системный вызов `socket()` сам возвращает файловый дескриптор, который является индексом в таблице файловых дескрипторов. 

Этот индекс указывает на структуру `file`, которая [содержит](obsidian://open?vault=my_notes&file=cs%2FCompArch%2FOS%2FFile%20descriptor) указатели на функции для работы с файлом или сокетом или любой другой сущностью, определяемой файловым дескриптором.

Эта связь позволяет процессам использовать стандартные системные вызовы для работы с сокетами, как если бы они работали с файлами (например `read()`, `write()`, `close()`).


Например:

```

Process
┌───────────────────────┐
│  FD Table             │
│  ┌─────┬────────────┐ │       Kernel Socket
│  │ 3   │  Socket    ├─┼─── → ┌─────────────────────┐
│  │     │ (sock_fd)  │ │      │ Type: TCP/UDP       │
│  └─────┴────────────┘ │      │ State: LISTEN       │
└───────────────────────┘      │ Local Address:      │
                               │   IP: 0.0.0.0       │
                               │   Port: 8080        │
                               └─────────────────────┘
```


---
## Socket internals

Ранее было упомянуто, что вся необходимая информация для межпроцессного взаимодействия (`IPC`) содержится в структуре `sock`. Разберём подробнее эти внутренности, чтобы лучше понять весь механизм взаимодействия между процессами и по сети.

На самом деле, структура `sock` внутри себя содержит структуру `sock_common`, которая является минимальным представлением сокета на уровне сетевого слоя.

Что же в ней содержится такого? А вот что:

- **Семейство адресов**: этот параметр определяет какой тип адресов используется сокетом. 
	- Например, `AF_INET` для протокола `IPv4`, `AF_INET6` для `IPv6`, `AF_UNIX` для локального межпроцессного взаимодействия и другие.

- **Адреса**: 
  - **Удаленный и локальный IP-адреса**: Эти адреса указывают на конечные точки соединения. В зависимости от конфигурации, это могут быть как `IPv4`, так и `IPv6` адреса. В структуре `sock_common` это представлено как объединение (`union`), что позволяет сокету гибко работать с разными типами адресов.

- **Порты**: 
  - **Удаленный и локальный порты**: Порты необходимы для идентификации конкретных приложений или услуг, использующих сеть. Они также организованы в виде `union`, что позволяет сокету гибко оперировать с портами разных протоколов.

- **Состояние соединения**: Это поле отображает текущее состояние сокета, например, установленное соединение, ожидание соединения, закрытие соединения и другие состояния. Это важно для управления жизненным циклом сокета и обработки сетевых событий.

- **Указатель на структуру `proto`**: Структура `proto` описывает функции и операции, которые используются для взаимодействия с конкретным сетевым протоколом. Это позволяет сокету выполнять действия, специфичные для протокола, такие как отправка и получение данных, управление соединением и другие операции.

- **Прочие параметры**: Мы перечислили только ключевые параметры этой структуры, необходимые для реализации сокета. Однако важно понимать, что это далеко не все и более детально можно ознакомиться [тут](https://github.com/torvalds/linux/blob/master/include/net/sock.h#L343)

---

## Network interaction via sockets

Сетевое взаимодействие на уровне приложений в операционных системах реализуются как раз через механизм сокетов.

Процесс взаимодействия начинается с создания сокета. Приложение или процесс (в случае `IPC`) инициирует этот шаг системным вызовом `socket()`, передавая ему три основных параметра: (семейство протоколов, тип сокета, протокол). В ответ на этот вызов ядро выделяет память под структуры `sock` и `sock_common`, инициализирует их соответствующими данными и возвращает приложению файловый дескриптор. Этот дескриптор является для приложения или процесса ключом к созданному сокету для всех последующих операций. На этом этапе сокет ещё не связан ни с каким конкретным сетевым адресом и не готов к обмену данными.

Следующим шагом, является привязка сокета к локальному адресу. Происходит это через системный вызов `bind()`. Приложению необходимо указать локальный `IP-adress`, на котором оно будет ожидать входящие запросы и номер порта. 

**Порт** представляет из себя 16-битное число (от 0 до 65535), которое служит для идентификации конкретного приложения или службы на хосте с заданным `IP-adress`. Комбинация `IP-adress` и номера порта однозначно определяет конечную точку связи на локальной машине. (Например веб-серверы традиционно используют порт 80 для `HTTP` и 443 для `HTTPS`).

Вызов `bind()`связывает ранее созданный (и пока безымянный) сокет с конкретной парой (`local_IP`:`local_port`), записывая эту информацию в соответствующие поля структуры `sock`. 

Если приложение не указывает конкретный `IP-adress` (`INADDR_ANY`), то система привязывает сокет ко всем доступным сетевым интерфейсам машины. Если указан порт 0, то система выберет свободный эфемерный порт. 

Клиентским приложениям обычно не требуется явно вызывать `bind()`, так как система автоматически назначает им свободный локальный порт при установке соединения.

Для серверного сокета типа `SOCK_STREAM (TCP)`, после успешной привязки, необходимо перевести его в **состояние прослушивания**. Это делается системным вызовом `listen()`. Этот вызов сообщает ядру, что данный сокет готов принимать входящие попытки соединения. Важным параметром `listen()` является `backlog` — размер очереди ожидающих соединений. Когда клиент инициирует соединение, а серверное приложение еще не успело его обработать вызовом `accept()`, запрос на соединение помещается в эту очередь. Если очередь переполнена, новые попытки соединения могут быть отклонены. Вызов `listen()` изменяет внутреннее **состояние** сокета (например, на `TCP_LISTEN)`, делая его слушающим" или "пассивным".


Теперь рассмотрим сторону **клиента**. Чтобы установить соединение с сервером, клиентское приложение, создавшее свой сокет (`SOCK_STREAM`), использует системный вызов `connect()`. Этому вызову передается дескриптор клиентского сокета и структура, содержащая **удаленный адрес**: `IP-adress` и порт сервера, к которому нужно подключиться. Вызов `connect()` инициирует процесс установления `TCP`-соединения (знаменитое "трехстороннее рукопожатие" - `three-way handshake`):

1. Клиент отправляет серверу `TCP`-сегмент с флагом `SYN` (`Synchronize`). Сокет клиента переходит в состояние `TCP_SYN_SENT`.
    
2. Сервер, получив `SYN`-сегмент на свой слушающий сокет, если в очереди `backlog` есть место, отвечает клиенту сегментом с флагами `SYN` и `ACK` (`Acknowledgment`). Запись о полу-открытом соединении создается на сервере.
    
3. Клиент, получив `SYN-ACK`, отправляет серверу сегмент с флагом `ACK`. Соединение считается установленным. Сокет клиента переходит в состояние `TCP_ESTABLISHED`.


Параллельно на **серверной стороне**, когда трехстороннее рукопожатие успешно завершено для входящего запроса, ядро перемещает информацию об этом установленном соединении из очереди ожидания (`backlog`) в очередь полностью установленных соединений для данного слушающего сокета. Серверное приложение, находящееся в ожидании на системном вызове `accept()` для своего слушающего сокета, будет разблокировано. 

Вызов `accept()` выполняет критически важную функцию: он **создает новый сокет** (с новым дескриптором файла), который представляет собой уже установленное, активное соединение с конкретным клиентом. Этот новый сокет наследует свойства слушающего сокета (тип, протокол), но теперь он связан не только с локальным адресом сервера, но и с **удаленным адресом** подключившегося клиента (его `IP` и портом). Вся дальнейшая коммуникация с этим конкретным клиентом будет происходить через этот новый сокет. Оригинальный слушающий сокет остается в состоянии `TCP_LISTEN`, готовый принимать следующие запросы на соединение от других клиентов.


После того как соединение установлено (на клиенте после успешного `connect()`, на сервере после `accept()` и получения нового дескриптора), обе стороны могут **обмениваться данными**. Для отправки данных используются системные вызовы `send()` или `write()`. 

Приложение передает этим вызовам дескриптор сокета, указатель на буфер с данными и размер данных. Ядро копирует данные из буфера приложения в **буфер отправки сокета** (`sk_sndbuf`) в структуре `sock`. Далее транспортный протокол (например, `TCP`) разбивает эти данные на сегменты подходящего размера, добавляет к ним заголовки (`TCP`-заголовок, содержащий порты, порядковые номера, флаги и т.д.), инкапсулирует их в `IP`-пакеты (добавляя `IP`-заголовки с `IP`-адресами источника и назначения) и передает нижележащим уровням сетевого стека для отправки через сетевой интерфейс.

`TCP` также обеспечивает надежность доставки: отслеживает отправленные сегменты, ожидает подтверждения (`ACK`) от получателя и повторно отправляет сегменты в случае их потери или искажения, используя информацию о состоянии и таймеры, хранящиеся в `sock`.


Для приема данных приложения используют системные вызовы `recv()` или `read()`. Когда данные поступают на сетевой интерфейс хоста, они проходят через сетевой стек в обратном порядке: деинкапсулируются из кадров канального уровня, затем из `IP`-пакетов. Транспортный протокол (`TCP`) проверяет контрольную сумму, извлекает данные из сегмента, обрабатывает порядковые номера для сборки потока данных в правильном порядке и помещает полученные байты в **буфер приема сокета** (`sk_rcvbuf`) в структуре `sock`. Если приложение вызывает `recv()`, ядро копирует данные из буфера приема сокета в буфер, предоставленный приложением. Если в буфере приема нет данных, вызов `recv()` может блокироваться (по умолчанию) до их появления. Размеры буферов отправки и приема влияют на производительность и управление потоком данных.


При этом на протяжении всего жизненного цикла сокет проходит через различные **состояния** (например, `CLOSED`, `LISTEN`, `SYN_SENT`, `SYN_RECV`, `ESTABLISHED`, `FIN_WAIT_1`, `FIN_WAIT_2`, `CLOSE_WAIT`, `LAST_ACK`, `TIME_WAIT`), которые отражают текущий этап процесса установки, обмена данными или закрытия соединения. Эти состояния управляются ядром на основе происходящих событий (вызовы системных функций, приход сетевых пакетов, истечение таймеров) и хранятся в структуре `sock`.


Наконец, когда обмен данными завершен, одна из сторон (или обе) инициирует **закрытие соединения**. Это делается системным вызовом `close()` на дескрипторе сокета. Для `TCP` это инициирует процедуру корректного завершения соединения (часто называемую "четырехсторонним рукопожатием" с использованием флагов `FIN - Finish`):

1. Сторона, вызвавшая `close()`, отправляет `FIN`-сегмент, указывая, что больше не будет отправлять данные. Ее сокет переходит в состояние `FIN_WAIT_1`.
    
2. Другая сторона, получив `FIN`, отправляет `ACK` в подтверждение. Ее сокет переходит в состояние `CLOSE_WAIT`. Приложение на этой стороне при попытке чтения из сокета получит признак конца файла (`EOF`). Оно также должно вызвать `close()` для своего сокета.
    
3. Когда вторая сторона вызывает `close()`, она отправляет свой `FIN`-сегмент. Ее сокет переходит в состояние `LAST_ACK`.
    
4. Первая сторона, получив `FIN`, отправляет `ACK`. Ее сокет переходит в состояние `TIME_WAIT` (для гарантии получения последнего `ACK` и обработки возможных запоздавших сегментов), а затем, по истечении тайм-аута, в `CLOSED`.
    
5. Вторая сторона, получив `ACK` на свой `FIN`, переходит в состояние `CLOSED`.
    

После перехода сокета в состояние `CLOSED` все связанные с ним ресурсы ядра, включая структуры `sock` и `sock_common`, а также выделенные буферы, освобождаются. Дескриптор файла становится недействительным.