
В контексте `concurrency`, термины `race condition` и `data race` часто используются как взаимозаменяемые, что приводит к путанице и неверному пониманию причин некорректного поведения  при исполнении. Однако, эти понятия имеют отчетливые различия, затрагивающие разные уровни абстракции и приводящие к различным классам ошибок.

## `Data race`

Современные многоядерные процессоры и компиляторы активно используют оптимизации, которые могут переупорядочивать операции чтения и записи в память, чтобы максимально эффективно использовать аппаратные ресурсы. Для обеспечения корректности в конкурентной среде, С++ и другие языки определяют строгие правила упорядочивания операций доступа к памяти, известные как `happens-before relation`. Нарушение этих правил при одновременном доступе к одной и той же ячейке памяти приводит к **гонке данных (`data race`)**.

**Data race** - это строго определённое нарушение правил упорядочивания операций доступа к памяти, которое возникает, когда:

- Два или более потоков исполнения конкурентно обращаются к одной и той же ячейке памяти.

- Хотя бы одна из этих операций является **записью (мутацией)** в эту ячейку.

- Между этими операциями отсутствует отношение  `happens-before`. То есть нет достаточной синхронизации, гарантирующей определённый порядок их выполнения.

Наличие гонки данных приводит к неопределённому поведению (в C++) при исполнении.


## `Race condition`

Даже если все отдельные операции доступа к памяти защищены на физическом уровне и не имеют гонок данных, последовательность выполнения этих атомарных операций в разных потоках может привести к логически неверному состоянию программы. Проблема возникает на более высоком уровне абстракций - уровне поддержания инвариантов данных.

`Race condition` - это явление, при котором корректность поведения конкурентной программы зависит от непредсказуемого относительного порядка выполнения операций в нескольких потоках, что может приводить к нарушению логических инвариантов системы или к недетерминированным результатам, даже если все индивидуальные доступы к памяти защищены от гонок данных.

В отличие от гонки данных, состояние гонки не обязательно приводит к неопределённому поведению. Часто это просто приводит к **неверным, но детерминированным** (или предсказуемым для каждого конкретного исполнения) результатам, которые однако меняются от исполнения к исполнению.

В качестве примера `race-condition` рассмотрим следующий код:

``` C++
std::atomic<int> balance = 100;

void add_money(int amount) {
    int current = balance;
    std::this_thread::sleep_for(std::chrono::milliseconds(1));
    balance = current + amount;
}

int main() {
    std::thread t1(add_money, 50);
    std::thread t2(add_money, 30);
    t1.join();
    t2.join();
    std::cout << balance;
}
```

Итоговый баланс зависит от **порядка выполнения** потоков.