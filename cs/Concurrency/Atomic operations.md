## Motivation

В начале 21-го века многоядерные процессоры стали обыденностью, а параллельное исполнение инструкций - не роскошью, а необходимостью. Перед инженерами появилась необходимость решить фундаментальную проблему - обеспечить корректный одновременный доступ к общему ресурсу из нескольких потоков исполнения. Без надлежащих механизмов синхронизации, параллельный доступ к разделяемому ресурсу неизбежно приводит к `data race`. Это порождает трудноуловимые ошибки, невоспроизводимые сбои и потенциальное нарушение инвариантности ресурса. В основе решения этой проблемы лежит **концепция атомарности**.


***Атомарность*** - это свойство операции, гарантирующее её выполнение как единого, логически неделимого и непрерывного действия, относительно операций остальной части системы.

То есть атомарная операция переводит систему из одного согласованного состояния (`consistent state`) в другое состояние, без возможности наблюдения или вмешательства со стороны других операций в промежуточные подсостояния, которые могут возникнуть во время её выполнения.

Формально: операция $\phi$ является **атомарной**, если для любого другого процесса или наблюдателя $P$, система наблюдается только в состоянии $S$ (до начала $\phi$) или только в состоянии $S'$ (после полного завершения $\phi$ ). Никакие промежуточные состояния, возникающие внутри логического выполнения $\phi$, не являются наблюдаемыми или доступными для наблюдателя $P$.

Атомарность имплицитно включает в себя несколько взаимосвязанных свойств:

- **Неделимость:** Операция не может быть разделена на более мелкие видимые компоненты. Ее выполнение представляет собой единый, непрерывный логический шаг. Даже если на физическом уровне операция состоит из множества микроопераций, на логическом уровне, релевантном для корректности параллельного выполнения, она едина

- **Изоляция:** Атомарная операция выполняется так, как будто она происходит в изоляции от всех других параллельно выполняющихся операций. Эффекты других операций не влияют на промежуточные шаги атомарной операции, и ее промежуточные эффекты не видны другим операциям до ее полного завершения

---
## `Linearizability`

Также, атомарность зачастую связана с более строгим свойством системы, известным как **линеаризуемость (`Linearizability`)**. Это свойство системы, гарантирующее, что каждая операция в системе представляет из себя мгновенный логический переход между состояниями вызова и завершения. 


При этом для выполнения линеаризуемости должен соблюдаться общий порядок выполнения всех операций. Он предполагает, что все операции можно выстроить в линейную последовательность, упорядоченною по времени выполнения.

И тут очень важно подметить, что линеаризуемость не требует, чтобы операции _реально_ выполнялись последовательно — она лишь накладывает ограничения на их наблюдаемое поведение:

- Если операция `A` завершилась до начала операции `B`, то в линейном порядке `A` будет перед `B`

- Если же `A` и `B` выполнялись параллельно, система может выбрать любой порядок их точек линеаризации (главное — чтобы он был согласованным для всех наблюдателей)


Линеаризуемость как свойство характеризуется **точками линеаризации**, определёнными для каждой операции.  Каждая точка линеаризации представляет из себя гипотетическую атомарную точку во времени, находящуюся внутри интервала выполнения операции `[unvokation, response]`, в которой операция изменяет наблюдаемое состояние системы в соответствии со своей семантикой. Все потоки в системе должны принять один и тот же глобальный порядок, определяемый точками линеаризации.

В качестве примера рассмотрим метод `lock()` в классе `std::mutex`:

``` C++
mutex.lock();
```

Для данной операции точкой линеаризации является момент времени, в котором, состояние блокировки изменяется (поток получает эксклюзивный доступ к критической секции) и все остальные потоки видят это изменение состояния.



В то время как атомарность гарантирует, что операция выполняется как единое целое и ее промежуточные состояния не видны наблюдателям, линеаризуемость является более сильным свойством корректности для всей системы . Это свойство не только требует атомарности каждой отдельной операции, но и накладывает строгие ограничения на наблюдаемый порядок выполнения всех операций в системе. Однако атомарность отдельных операций **не гарантирует** линеаризуемость системы в целом.

---

## `Atomics`

Мы установили, что **атомарность** — это критически важное свойство неделимости операции в мире параллельных вычислений, защищающее систему от хаоса состояний гонки. Но как же воспользоваться этим свойством на практике? Как потребовать, чтобы конкретная операция, скажем, увеличение счетчика или обновление указателя, действительно была выполнена атомарно?

 В этом помогают **атомарные типы данных** и **атомарные операции**, предоставляемые современными языками программирования и операционными системами. Они инкапсулируют низкоуровневые аппаратные или программные механизмы, необходимые для обеспечения атомарности, и представляют их в стандартизированном виде. Их часто обобщенно называют **(`atomics`)**. Например, в `C++` стандартная библиотека предоставляет шаблонный тип `std::atomic<T>`, который позволяет создавать объекты типа `T`, операции над которыми будут атомарными.

``` C++
#include <atomic>
#include <thread>
#include <vector>
#include <iostream>

std::atomic<int> atomic_counter = 0; // atomic counter
int non_atomic_counter = 0; // classic counter for comparison

void increment_counters() {
    for (int i = 0; i < 100000; ++i) {
        atomic_counter++;
        non_atomic_counter++;
    }
}

int main() {
    std::vector<std::thread> threads;
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back(increment_counters);
    }

    for (auto& t : threads) {
        t.join();
    }

    std::cout << "Atomic counter final value: " << atomic_counter << std::endl;
    // predictable value: 10 * 100000 = 1000000

    std::cout << "Non-atomic counter final value: " << non_atomic_counter << std::endl;
    // unpredictable

    return 0;
}
```

В приведенном примере `atomic_counter++` выполняется атомарно, гарантируя результат `1,000,000`. В то же время `non_atomic_counter++` подвержен состоянию гонки, и его конечное значение не определено.

---
### `Atomics under the hood`

Теперь настало время разобраться, как же магия атомарности воплощается в реальность на аппаратном уровне? Ведь за кулисами интерфейса вроде `std::atomic` скрывается иерархия механизмов, берущая своё начало на самом фундаментальном уровне - `CPU`.

Современные архитектуры процессоров не случайно включают в свой набор команд специальные привилегированные атомарные машинные инструкции. Они спроектированы именно для того, чтобы справиться с классической проблемой операции типа `Read-Modify-Write, (RMW)`. Вспомним пример с инкрементом `counter++`: для выполнения этой операции требуется прочитать текущее значение, изменить его и записать обратно. Если эти три этапа не объединены в единое, неделимое целое, возникает окно уязвимости для состояния гонки. Атомарные инструкции `CPU` закрывают это окно, гарантируя, что вся `RMW` последовательность выполняется так, как будто это одно мгновенное событие, относительно выполнения инструкций на других ядрах или устройствах, пытающихся получить доступ к ресурсу по тому же адресу. 

Для того чтобы операция типа `RMW` была истинно атомарной в конкурентной системе, необходимо гарантировать, что никакая другая сущность не сможет вмешаться в эту последовательность между этапом чтения и этапом записи по тому же адресу. Аппаратное обеспечение достигает этой изоляции преимущественно двумя способами, различающимися по гранулярности и влиянию на производительность системы: **блокировкой системной шины** и **использованием протоколов когерентности кэшей**.

---
### `Bus locking`

Этот механизм обеспечивает атомарность путём временного предоставления одному из ядер монопольного доступа к системной шине, которая является общей магистралью для коммуникации между ядрами, памятью и периферийными устройствами.

Когда ядро инициирует атомарную операцию, требующую блокировку шины, оно выставляет специальный управляющий сигнал шине (`LOCK#` in `x86`). Этот сигнал служит запросом на эксклюзивный доступ. Контроллер шины предоставляет доступ этому ядру и запрещает всем остальным устройствам начинать новые транзакции на шине до тех пор, пока запрашивающее ядро не завершит свою атомарную операцию и не снимет сигнал блокировки. В течение этого интервала процессор выполняет всю `RMW` последовательность без риска вмешательства. 

Блокировка останавливает все транзакции на шине, а не только те, что направлены к конкретной ячейке памяти. Это затрагивает и другие ядра, даже если они работают с совершенно другими областями памяти или устройствами. Захват и освобождение шины, а также ожидание другими устройствами вносят существенные задержки.

Однако в настоящее время блокировка шины является достаточно устаревшим механизмом и используется реже, но всё еще может быть задействована в некоторых случаях. Например при использовании явного префикса `LOCK` с некоторыми инструкциями `x86`, когда операция затрагивает память, которая не кэшируется или операция пересекает границу кэш-линии. (Протоколы когерентности обычно оперируют целыми кэш-линиями, и гарантировать атомарность для операции, изменяющей две линии одновременно через протокол когерентности, может быть сложно или невозможно аппаратно, поэтому система откатывается к блокировке шины).

---
### `Cache coherency`

В современных многоядерных системах каждое процессорное ядро обладает собственной быстрой кэш-памятью для ускорения доступа к часто используемым данным из более медленной основной памяти (`RAM`). Однако это порождает фундаментальную проблему: одна и та же ячейка основной памяти может иметь несколько копий, хранящихся в кэшах разных ядер. Если одно ядро модифицирует свою копию, как гарантировать, что другие ядра не будут работать с устаревшими данными, и что все ядра в конечном итоге увидят согласованную картину состояния памяти? Решение этой проблемы и есть **когерентность кэшей**.

**Когерентность кэшей** — это свойство системы разделяемой памяти, гарантирующее, что все копии разделяемого ресурса, хранящиеся в локальных кэшах, остаются согласованными. Формально, система памяти считается когерентной, если она удовлетворяет двум основным инвариантам:

1. **Write Propagation:** Изменения, сделанные одним ядром в определенной ячейке памяти, должны со временем стать видимыми для всех других ядер, которые попытаются прочитать эту ячейку
    
2. **Transaction Serialization:** Все операции записи в одну и ту же ячейку памяти должны наблюдаться всеми процессорами в одном и том же порядке. То есть, если ядра `K_1` и `K_2` наблюдают последовательность записей в ячейку `X` как `Write(X, A)` затем `Write(X, B)`, то ни одно ядро не может наблюдать эту последовательность как `Write(X, B)` затем `Write(X, A)`


**Протокол когерентности кэшей** — это конкретный набор правил и сообщений, используемых контроллерами кэшей и `mmu` для поддержания когерентности кэшей в многоядерной системе. Протокол определяет:

- **Состояния (States):** Набор возможных состояний, в которых может находиться каждая **кэш-линия** в локальном кэше (например, `Modified`, `Exclusive`, `Shared`, `Invalid` в протоколе `MESI`)

- **События (Events):** Типы событий, которые могут инициировать изменение состояния или обмен сообщениями 

- **Переходы Состояний (State Transitions):** Правила, по которым кэш-линия переходит из одного состояния в другое в ответ на локальные или внешние события

- **Действия (Actions):** Действия, которые должен выполнить контроллер кэша при определенных событиях или переходах состояний (например, отправить данные на шину, инвалидировать локальную копию, обновить локальную копию)


![](https://i.imgur.com/ajHWbqS.jpeg)



Роль протокола когерентности фундаментальна: он является механизмом принудительного выполнения свойств когерентности. Он активно управляет состоянием кэш-линий во всех кэшах системы, отслеживая, какие ядра имеют копии ресурса, кто имеет эксклюзивные права на запись, и кто владеет самой последней версией ресурса. В контексте атомарных операций его ключевая роль заключается в **арбитраже доступа к кэш-линиям для записи**, гарантируя, что только одно ядро в любой момент времени может модифицировать данную кэш-линию, тем самым обеспечивая необходимую **изоляцию** для выполнения атомарных `RMW` операций.


И так, вернёмся к аппаратной реализации атомарной операции. Как указывалось ранее, когерентность кэшей является одним из решений этого вопроса. Способ, который основан на этом свойстве, значительно эффективнее по сравнению с блокировкой шины. Он использует встроенные механизмы процессора для поддержания согласованности ресурса, находящегося в локальных кэшах разных ядер. Атомарность `RMW` операции достигается путём **получения эксклюзивных прав на запись** в **конкретную кэш-линию** на время выполнения операции. Другие ядра могут одновременно и беспрепятственно работать с ресурсом, находящимся в других кэш-линиях. Это позволяет эффективно масштабировать производительность с увеличением числа ядер в системе.


Как же происходит это получение прав на запись? Когда ядро `CPU` хочет выполнить атомарную `RMW` операцию над ресурсом в определённой кэш-линии, оно инициирует транзакцию на шине или через межъядерное соединение. Данная транзакция является запросом на получение этой линии в эксклюзивном ` Exclusive (E)` или модифицированном состоянии `Modified (M)`. 

Протокол когерентности обеспечивает разрешение этого запроса. Если другие ядра имеют копию этой линии в состоянии `Shared (S)`, их копии инвалидируются (переводятся в состояние `Invalid (I)`). В случае, если другое ядро имеет линию в состоянии `Modified` (данные изменены, но они ещё не записаны назад), оно должно сначала записать свои изменения в память (write-back) или напрямую передать актуальные данные ядру, выполняющему атомарную операцию. После этого его копия также переходит в состояние `Invalid`.

Как только ядро успешно получает кэш-линию в эксклюзивное владение, оно может безопасно выполнить всю последовательность `RMW` локально в своём кэше. В этот момент никакое другое ядро не имеет валидной копии этой линии и не может вмешаться в операцию. После завершения `RMW` кэш-линия остаётся у вызывающего ядра в состоянии `Modified`. Протокол когерентности далее управляет распостранением этого изменения при последующих запросах от других ядер.

Этот подход является стандартным для обеспечения атомарности большинства `RMW` инструкций при работе с кэшируемым ресурсом, при условии, что операнд полностью помещается в одну кэш-линию.

---
### Instructions

Итак, мы выяснили, что механизмы блокировки шины и когерентности кэшей являются аппаратными фундаментами, позволяющими процессору выполнять операции неделимо. Но какие именно **конкретные инструкции** `CPU` использует для реализации атомарных операций, которые мы видим в языках вроде `C++`? Давайте рассмотрим ключевые из них, а также механизм, к которому прибегает система при отсутствии прямой аппаратной поддержки.

---
#### Atomic `load`/`store`

На первый взгляд, обычное чтение (`Load`) и запись (`Store`) кажутся элементарными. Однако необходимость в их атомарности возникает при работе с данными, размер которых превышает естественную ширину шины данных, или в случае, когда данные не выровнены по естественным границам.

Основная проблема здесь — **(word tearing)**. Например, при записи 64-битного значения на 32-битной шине, операция может разбиться на два этапа. Если другой поток попытается прочитать это значение между этапами, он рискует получить некорректную комбинацию старых и новых байт. Атомарное `Load/Store`, гарантированное аппаратно (обычно для выровненных данных нативного размера), предотвращает эту проблему, обеспечивая, что чтение всегда возвращает целостное значение, а запись переводит ячейку из одного целостного состояния в другое

То есть обычная инструкция `mov [memory], rax` является атомарным `store`. А всё потому, что на `x86 32/64` чтения/записи выровненных (aligned) данных нативного размера атомарны по умолчанию.

---
#### `CAS (compare and swap)`

Это, пожалуй, самая универсальная и мощная атомарная инструкция, лежащая в основе множества `lock-free` алгоритмов. Её суть — **условная атомарная запись**. 

`CAS` (или ее аналоги) обычно принимает три операнда:

- `V`: Адрес ячейки для модификации
 
- `A`: Значение, которое ожидается найти в ячейке с адресом `V`

- `B`: Новое значение, которое нужно записать по адресу `V`, если текущее значение равно `A`

В `C++` ей соответствуют `std::atomic::compare_exchange_strong` и `std::atomic::compare_exchange_weak`. Последняя может возвращать `spurious failure`, что иногда позволяет повысить производительность. `CAS` позволяет реализовать оптимистический подход: поток читает значение, выполняет вычисления и пытается обновить его через `CAS`, проверяя, не изменилось ли значение за это время

---
#### `Atomic swap/exchange`

Эта инструкция выполняет **безусловную атомарную замену** значения по адресу. Она принимает адрес (`V`) и новое значение (`new_val`). Атомарно читает текущее значение (`current`) по адресу `V`, записывает `new_val` в `V` и возвращает `current`. 

В `C++` это `std::atomic::exchange(new_val)`. Она полезна, когда нужно гарантированно установить новое состояние, получив при этом предыдущее.


---

Но что происходит в случае, если нам нужна атомарность для типа, для которого нет прямой аппаратной инструкции? Например для большой структуры `std::atomic<MyBigStruct>`.

В таких случаях стандартная библиотека `C++` (и другие подобные соглашения) прибегают к программной эмуляции атомарности с использованием блокировок.

Для каждого такого `non-lock-free` объекта `std::atomic<T>` неявно создается и ассоциируется с ним внутренний мьютекс. Каждая операция над этим объектом (`load`, `store`, `compare_exchange`, ...) перед выполнением захватывает этот мьютекс, выполняет эквивалентное неатомарное действие над ресурсом, а затем освобождает мьютекс.

Это гарантирует требуемую неделимость операции, так как мьютекс унифицирует доступ к объекту. Однако платой является значительное снижение производительности по сравнению с аппаратными атомиками из-за накладных расходов на операции с мьютексом, особенно в условиях конкуренции (блокировка потока, переключение контекста).

В `C++` существует метод `is_lock_free()`, который позволяет позволяет проверить, поддерживается ли данный тип аппаратными инструкциями. В противном случае метод вернёт `false`, что будет означать, что при выполнении операции над объектом данного типа будет использована эмуляция на блокировках. Для стандартных целочисленных типов и указателей на большинстве современных платформ `std::atomic` является `lock-free`.


