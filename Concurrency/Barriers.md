Одной из основных оптимизаций современных процессоров и компиляторов является переупорядочивание инструкций, в том числе чтение и записи в память. Это означает, что последовательность операций, заданная в исходном коде, не обязательно будет точно соблюдаться при их фактическом выполнении процессором.

Для однопоточной среды такое переупорядочивание обычно безвредно, поскольку процессор гарантирует, что видимый результат выполнения программы не изменится.


Однако в условиях конкурентного доступа к общей изменяемой памяти (`shared muteble state`) переупорядочивание становится источником неопределённого поведения.

Представим сценарий, где один поток записывает несколько значений в общую структуру данных, а затем устанавливает флаг, сигнализирующий о завершении записи. Другой поток, видя установленный флаг, начинает чтение этих данных. Если операции записи и чтения были переупорядочены и флаг был установлен до того, что все данные были фактически записаны и стали видимы, второй поток может прочитать неполноценные или устаревшие значения.

Разрешить эту проблему позволяют ***барьеры памяти***. Они определяются как специальные инструкции, которые предписывают ядру процессора или компилятору наложить ограничение на порядок операций с памятью, выданных до и после инструкции барьера. Это гарантирует, что операции, расположенные до барьера, гарантированно будут выполнены до операций, расположенных после барьера. 

Если говорить неформально, то барьер памяти служит точкой синхронизации, которая контролирует, в каком порядке операции с памятью становятся видимыми для других потоков.


---
## `Classification`

Существуют различные типы барьеров памяти, обеспечивающие разные уровни синхронизации и гарантий упорядочивания:

- `Full Memory Barrier/ Bidirectional Fence` - Это тип барьера, который гарантирует, что все операции чтения (`loads`) и записи (`stores`), указанные до барьера, будут выполнены до всех операций чтения и записи, указанных после барьера. Это наиболее строгий тип барьера.

- `Store Barrier` - Это тип барьера, который гарантирует, что все операции записи (`stores`) перед барьером будут видимы другим потокам до того, как будут выполнены любые операции сохранения после барьера. Он упорядочивает только операции записи.

- `Load Barrier` - Это тип барьера, который гарантирует, что все операции чтения (`loads`) перед барьером будут выполнены до того, как будут выполнены любые операции чтения после барьера. Он упорядочивает только операции чтения.

---
## `Relations with Atomics`

Атомарные операции сами по себе гарантируют неделимость конкретной операции. Однако атомарность операции не гарантирует порядок, в котором окружающие инструкции выполняются или становятся видимыми для других потоков. Именно здесь барьеры памяти становятся критически важными для избежания `race condition`.

Атомарные операции часто подразумевают использование барьеров памяти для обеспечения корректной видимости и упорядочивания. Например, в языке `C++` стандартная библиотека для типа `std::atomic` позволяет явно указать модель упорядочивания памяти (`std::memory_order`), которая по сути, определяет тип используемого барьера памяти.


``` C++
int data = 0;
std::atomic<bool> ready = false;

void producer_thread_task() {
	data = 42;
	ready.store(true, std::memory_order_release); // explicit release barrier
}

void consumer_thread_task() {
	while (!ready.load(std::memory_order_acquire)) {
	// waiting untill 'ready' becomes true	
	}

	int value = data; // value here is guaranteed 42
}
```


---
## Assembly implementation

На уровне ассемблера, барьеры памяти реализуются как специфические машинные инструкции, которые архитектура процессора предоставляет для управления порядком операций с памятью.

В данном конспекте рассмотрим в качестве примера набор инструкций для архитектуры `x86/64`:

- `SFENCE (Store Fence)`: [Инструкция](https://www.dapsen.com/X86/html/file_module_x86_id_289.html), реализующая `Store Barrier`. Гарантирует, что все предыдущие ей операции записи будут исполнены до выполнения любой последующей ей операции записи.

- `LFENCE (Load Fence)`: [Инструкция](https://www.felixcloutier.com/x86/lfence), реализующая `Load Barrier`. Гарантирует, что все предыдущие ей операции чтения будут завершены до выполнения любой последующей ей операции чтения. Не мешает процессору предварительно загружать данные из памяти, но гарантирует, что последующие инструкции не будут выполняться, пока `LFENCE` не завершится.

- `MFENCE (Memory Fence)`: [Реализация](https://www.felixcloutier.com/x86/mfence) для `Full Memory Barrier`. Гарантирует, что все предыдущие ей операции чтения и записи будут завершены и станут глобально видимыми до выполнения любой последующей ей операции чтения или записи. Это наиболее строгий барьер, эквивалентный комбинации `lfence` и `sfence`.

