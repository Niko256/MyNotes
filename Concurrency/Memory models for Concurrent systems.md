
## The End of the Single-threaded fairy tale.

### The `as-if` rule.

В мире однопоточной среды исполнения, разработчики десятилетиями жили под защитой простого соглашения, известного как **принцип `as-if`**.

Этот принцип достаточно краток и понятен : компилятор языка программирования и процессор имеют право производить любые преобразования и оптимизации программы : менять инструкции местами, удалять избыточные инструкции, кэшировать значения в регистрах - до тех пор, пока наблюдаемое поведение программы в рамках одного потока остаётся таким же, как если бы она исполнялась в точности так, как было написано в её исходном коде.

Для нас это был идеальный мир, в котором можно было писать простой, последовательный код, а компилятор и новое поколение процессоров брали на себя магию его оптимизации и ускорения. Детали этих преобразований оставались скрытыми от нас. Главное, что конечный результат был корректным и предсказуемым.

### The multi-core revolution

Эта модель, в которой оптимизации были невидимым благом, закончилась с наступлением эры многоядерных процессоров. Появление множества ядер, а с ними и потоков исполнения, добавило в систему *сторонних наблюдателей*. И эти наблюдатели смогли увидеть то, что раньше было скрыто внутри принципа `as-if`, а именно внутренние трюки компилятора и процессора. Оптимизации, абсолютно безопасные для однопоточной среды, внезапно стали приводить к видимым и зачастую катастрофическим последствиям.

Рассмотрим классический пример, демонстрирующий суть проблемы. Предположим, что мы в одном потоке подготавливаем какой-то ресурс, а затем выставляем флаг, сигнализируя второму потоку, что ресурс готов.

``` C++
int x = 0;
bool done = false;

/* Thread#1 */
x = 42;

/* Thread#2 */
while (!done) {
	done = true;
}

std::cout << x << std::endl; // expecting 42 here...
```

Наше намерение здесь чисто: второй поток должен увидеть `x = 42`. В однопоточной среде порядок `x = 42` и `done = true` был бы незыблем. Но с точки зрения компилятора, оптимизирующего первый поток, переменные `x` и `done` никак не связаны между собой. Он может счесть для себя более эффективным, что сначала эффективней будет выполнить `done = true`, а затем уже `x = 42` (например для более оптимального использования регистров). Такое переупорядочивание само по себе не нарушает логику первого потока, но для второго потока оно фатально : он *может* прочитать `done = true`, выйти из цикла и прочитать из `x` старое значение `0`.

И даже если компилятор сгенерирует инструкции в правильном порядке, то нам также не стоит забывать, что многоядерные процессоры - это невероятно сложные системы с аппаратной точки зрения и они также являются авторами проблем в конкурентной среде. Далее мы разберём проблему детальнее, но вообще говоря, процессорное ядро, выполнив запись `x = 42`, скорее всего, отложит эту запись в специальный *буфер*, чтобы не простаивать при следующем обращении. А вот следующая запись `done = true` может быть выполнена и стать видимой для остальных ядер быстрее, чем первая запись. Снова получаем тот же результат : второй поток видит флаг, но не видит *вроде-как* записанного ресурса.

### So, what is a MM?

Именно этот конфликт между нашими желаниями предсказуемого порядка выполнения и стремлением системы к производительности, привёл человечество к необходимости формализации нового контракта. Этот контракт и есть **Модель памяти (`MM`)**.

```
Модель памяти - это набор правил, являющийся частью спецификации языка программирования и/или аппаратной архитектуры, который определяет, какие значения может увидеть операция чтения из памяти.
```

***=> Модель памяти определяет и описывает допустимые поведения многопоточной программы***

И тут важно понимать, что это не просто набор рекомендаций, а строгий протокол взаимодействия между тремя сторонами : программистом, компилятором и разработчиком аппаратного обеспечения. Мы, как программисты, обязуемся использовать специальные инструменты, например такие как атомарные переменные, помечая компилятору и процессору точки, в которых стоит действовать согласно протоколу. Взамен, компилятор и процессор гарантируют, что в этих точках они не будут нарушать наши ожидания, но оставляют за собой право на любые оптимизации в остальном коде.

### The actors and the distributed system view

Чтобы понять в полной мере природу проблемы, полезно перестать думать о процессоре как о монолитной сущности. По своей сути, современный многоядерный процессор - это распределённая система.

В этой распределённой системе у нас есть :

- **независимые узлы в виде процессорных ядер**, каждое из которых имеет своё состояние (регистры) и локальные оптимизации (`store buffers`).

- **локальные кэши**

- **общая сеть** в виде системной шины и иерархии памяти, через которую узлы обмениваются информацией. Эта сеть имеет свои задержки и особенности.

И когда мы смотрим на проблему под этим неочевидным углом, становится очевидно, что MM - это по сути протокол консистентности для этой распределённой системы. То есть модели памяти - это не про `reordering`'и и `memory_order`'ы, которые часто все пытаются заучить как стих, в реальности всё куда сложнее. И для полноценного понимания механизма, нужно думать не в категориях переупорядочиваний, а в категорях частичных порядков отношений и гарантий, не забывая учитывать часть договора с аппаратной стороны.

***Исполнение любой многопоточной программы - это не единая временная шкала, а сложный граф событий, связанных между собой отношениями причинности***. Различные `memory_order::` - это лишь инструменты, используя которые, мы добавляем в этот граф недостающие рёбра (отношения записей и чтений), чтобы сделать исполнение программы предсказуемым и эффективным.

## The physical reality : Hardware MMs.

